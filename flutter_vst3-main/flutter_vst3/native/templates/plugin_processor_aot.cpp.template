// Copyright (c) 2025
// Auto-generated VST3 processor for {{PLUGIN_NAME}} using AOT-compiled Dart code
// This file is generated automatically by dart_vst3_bridge at build time.
// DO NOT EDIT - any changes will be overwritten.

#include "{{PLUGIN_ID}}_ids.h"
#include "pluginterfaces/vst/ivstparameterchanges.h"
#include "pluginterfaces/vst/ivstprocesscontext.h"
#include "pluginterfaces/base/ibstream.h"
#include "public.sdk/source/vst/vstaudioeffect.h"
#include "base/source/fstreamer.h"
// Using native AOT-compiled Dart processor - NO FFI BRIDGE!
extern "C" {
    void {{PLUGIN_ID}}_native_initialize(double sample_rate, int max_block_size);
    void {{PLUGIN_ID}}_native_process_stereo(float* inputL, float* inputR, float* outputL, float* outputR, int samples);
    void {{PLUGIN_ID}}_native_set_parameter(int param_id, double value);
    double {{PLUGIN_ID}}_native_get_parameter(int param_id);
    void {{PLUGIN_ID}}_native_reset();
    void {{PLUGIN_ID}}_native_dispose();
}
#include <cstring>
#include <stdexcept>

using namespace Steinberg;
using namespace Steinberg::Vst;

// Processor for the {{PLUGIN_NAME}} plugin
class {{PLUGIN_CLASS_NAME}}Processor : public AudioEffect {
public:
    {{PLUGIN_CLASS_NAME}}Processor();
    virtual ~{{PLUGIN_CLASS_NAME}}Processor() = default;

    tresult PLUGIN_API initialize(FUnknown* context) override;
    tresult PLUGIN_API terminate() override;
    tresult PLUGIN_API setActive(TBool state) override;
    tresult PLUGIN_API process(ProcessData& data) override;
    tresult PLUGIN_API setupProcessing(ProcessSetup& setup) override;
    tresult PLUGIN_API setBusArrangements(SpeakerArrangement* inputs, int32 numIns,
                                          SpeakerArrangement* outputs, int32 numOuts) override;
    tresult PLUGIN_API setState(IBStream* state) override;
    tresult PLUGIN_API getState(IBStream* state) override;
    tresult PLUGIN_API getControllerClassId(TUID classId) override;

private:
{{PARAMETER_VARIABLES}}
    double sampleRate = 44100.0;
    
    // Native AOT processor - NO MORE DART RUNTIME DEPENDENCY!
    bool nativeProcessorInitialized = false;
};

{{PLUGIN_CLASS_NAME}}Processor::{{PLUGIN_CLASS_NAME}}Processor() {
    setControllerClass(k{{PLUGIN_CLASS_NAME}}ControllerUID);
    
    // ARCHITECTURE FIXED: Using AOT-compiled native Dart code - NO RUNTIME DEPENDENCY!
    nativeProcessorInitialized = false;
{{PARAMETER_DEFAULTS}}
}

tresult {{PLUGIN_CLASS_NAME}}Processor::initialize(FUnknown* context) {
    tresult result = AudioEffect::initialize(context);
    if (result != kResultTrue) return result;

    // Configure audio buses - stereo in/out by default
    addAudioInput(STR16("Stereo In"), SpeakerArr::kStereo);
    addAudioOutput(STR16("Stereo Out"), SpeakerArr::kStereo);

    return kResultTrue;
}

tresult {{PLUGIN_CLASS_NAME}}Processor::terminate() {
    if (nativeProcessorInitialized) {
        {{PLUGIN_ID}}_native_dispose();
        nativeProcessorInitialized = false;
    }
    return AudioEffect::terminate();
}

tresult {{PLUGIN_CLASS_NAME}}Processor::setActive(TBool state) {
    if (state) {
        // Plugin activated - TRY to initialize native AOT processor and FAIL HARD if it doesn't work
        try {
            {{PLUGIN_ID}}_native_initialize(sampleRate, 512);
            nativeProcessorInitialized = true;
        } catch (const std::exception& e) {
            // FAIL HARD! CRASH THE WHOLE DAW!
            fprintf(stderr, "{{PLUGIN_ID}} CRITICAL FAILURE: AOT processor initialization failed: %s\n", e.what());
            fprintf(stderr, "THIS PLUGIN REQUIRES WORKING AOT COMPILATION!\n");
            fflush(stderr);
            abort(); // CRASH THE DAW - NO SILENT FAILURES!
        }
    } else {
        // Plugin deactivated - reset native processor
        if (nativeProcessorInitialized) {
            try {
                {{PLUGIN_ID}}_native_reset();
            } catch (...) {
                // Even cleanup failures should crash
                abort();
            }
        }
    }
    return AudioEffect::setActive(state);
}

tresult {{PLUGIN_CLASS_NAME}}Processor::setupProcessing(ProcessSetup& setup) {
    sampleRate = setup.sampleRate;
    return AudioEffect::setupProcessing(setup);
}

tresult {{PLUGIN_CLASS_NAME}}Processor::setBusArrangements(SpeakerArrangement* inputs, int32 numIns,
                                                          SpeakerArrangement* outputs, int32 numOuts) {
    // Only accept stereo input/output
    if (numIns == 1 && numOuts == 1 && inputs[0] == SpeakerArr::kStereo && outputs[0] == SpeakerArr::kStereo) {
        return AudioEffect::setBusArrangements(inputs, numIns, outputs, numOuts);
    }
    return kResultFalse;
}

tresult {{PLUGIN_CLASS_NAME}}Processor::process(ProcessData& data) {
    // Process parameter changes
    if (data.inputParameterChanges) {
        int32 numParamsChanged = data.inputParameterChanges->getParameterCount();
        for (int32 i = 0; i < numParamsChanged; i++) {
            IParamValueQueue* paramQueue = data.inputParameterChanges->getParameterData(i);
            if (paramQueue) {
                ParamValue value;
                int32 sampleOffset;
                int32 numPoints = paramQueue->getPointCount();
                
                if (paramQueue->getPoint(numPoints - 1, sampleOffset, value) == kResultTrue) {
                    // Forward parameter changes to native AOT processor
                    if (nativeProcessorInitialized) {
                        {{PLUGIN_ID}}_native_set_parameter(paramQueue->getParameterId(), value);
                    }
                }
            }
        }
    }

    // Process audio
    if (data.numInputs == 0 || data.numOutputs == 0) {
        return kResultOk;
    }

    AudioBusBuffers* input = &data.inputs[0];
    AudioBusBuffers* output = &data.outputs[0];
    
    int32 numChannels = input->numChannels;
    int32 sampleFrames = data.numSamples;
    
    if (numChannels > 0 && sampleFrames > 0) {
        if (nativeProcessorInitialized && numChannels >= 2) {
            // Process stereo audio through AOT-compiled native Dart code - ZERO FFI OVERHEAD!
            Sample32* inputL = input->channelBuffers32[0];
            Sample32* inputR = input->channelBuffers32[1];
            Sample32* outputL = output->channelBuffers32[0];
            Sample32* outputR = output->channelBuffers32[1];
            
            try {
                {{PLUGIN_ID}}_native_process_stereo(inputL, inputR, outputL, outputR, sampleFrames);
            } catch (const std::exception& e) {
                // FAIL HARD! CRASH THE WHOLE DAW!
                fprintf(stderr, "{{PLUGIN_ID}} CRITICAL FAILURE: Audio processing failed: %s\n", e.what());
                fflush(stderr);
                abort(); // CRASH THE DAW - NO SILENT FAILURES!
            }
        } else {
            // NO FALLBACKS! FAIL HARD! CRASH THE DAW!
            fprintf(stderr, "VST3 PROCESSOR CRITICAL FAILURE: Native AOT processor not initialized or audio is not stereo!\n");
            fprintf(stderr, "nativeProcessorInitialized: %s, numChannels: %d\n", 
                   nativeProcessorInitialized ? "true" : "false", numChannels);
            fflush(stderr);
            abort(); // CRASH THE WHOLE DAW!
        }
    }

    return kResultOk;
}

tresult {{PLUGIN_CLASS_NAME}}Processor::setState(IBStream* state) {
    if (!state) return kResultFalse;

    // Read parameter values
{{PARAMETER_STATE_READ}}

    return kResultOk;
}

tresult {{PLUGIN_CLASS_NAME}}Processor::getState(IBStream* state) {
    if (!state) return kResultFalse;

    // Write parameter values
{{PARAMETER_STATE_WRITE}}

    return kResultOk;
}

tresult {{PLUGIN_CLASS_NAME}}Processor::getControllerClassId(TUID classId) {
    memcpy(classId, k{{PLUGIN_CLASS_NAME}}ControllerUID, sizeof(TUID));
    return kResultTrue;
}

// Factory functions in proper namespace  
namespace Steinberg {
namespace Vst {
namespace {{PLUGIN_CLASS_NAME}} {
    FUnknown* createProcessorInstance(void*) {
        return (IAudioProcessor*)new {{PLUGIN_CLASS_NAME}}Processor();
    }
}
}
}