
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Noisetown Ultimate — v4 (Per‑Stream Spaces, Spectrogram, Tooltips, Presets, Style Mode)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root{
    --bg:#121212; --panel:#1e1e1e; --card:#222; --text:#f0f0f0; --muted:#bbb; --accent:#59a7ff;
    --select:#1b1e28; --select-border:#666;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Tahoma,Arial,sans-serif}
  #app{display:flex;flex-direction:column;height:100%}
  #toolbar{display:flex;gap:10px;align-items:center;padding:10px;background:var(--panel);border-bottom:1px solid #444;position:sticky;top:0;z-index:5}
  #main{flex:1;overflow:auto;padding:10px;display:flex;gap:10px;flex-wrap:wrap;position:relative}
  .block{background:var(--panel);border:1px solid #444;border-radius:8px;padding:10px;min-width:520px}
  .block.dragging{opacity:.95;outline:2px dashed var(--accent)}
  .block h2{margin:0 0 8px}
  .block .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin:6px 0}
  .block.plugin-block{min-width:720px;padding:18px;border-radius:12px;border:1px solid #353f52;background:linear-gradient(160deg,rgba(20,22,30,.94),rgba(10,12,18,.92));box-shadow:0 26px 48px rgba(0,0,0,.4)}
  .plugin-block .studio-header{display:flex;flex-wrap:wrap;align-items:center;gap:12px}
  .plugin-block .studio-header h2{margin:0;font-size:22px;display:flex;align-items:center;gap:8px}
  .plugin-block .studio-header .tagline{font-size:13px;color:var(--muted)}
  .plugin-block .studio-header .status-text{margin-left:auto;padding:6px 12px;border-radius:999px;background:rgba(89,167,255,.16);border:1px solid rgba(89,167,255,.35);font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px}
  .plugin-block.server-offline .studio-header .status-text{color:#ff8b8b;border-color:rgba(255,139,139,.6);background:rgba(255,139,139,.12)}
  .plugin-block .studio-grid{display:grid;gap:18px;grid-template-columns:minmax(260px,320px) minmax(320px,1fr);align-items:start}
  @media (max-width:1100px){.plugin-block .studio-grid{grid-template-columns:1fr}}
  .plugin-block .workspace-panel{display:flex;flex-direction:column;gap:14px;padding:16px;border-radius:12px;background:rgba(12,16,24,.9);border:1px solid rgba(255,255,255,.08);box-shadow:0 16px 28px rgba(0,0,0,.3)}
  .plugin-block .workspace-panel header{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .plugin-block .workspace-panel h3{margin:0;font-size:16px}
  .plugin-block .workspaceHint{font-size:12px;color:var(--muted)}
  .plugin-block .workspacePathRow{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .plugin-block .workspacePath{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.08)}
  .plugin-block .workspaceList{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px}
  .plugin-block .workspaceList li{border-radius:10px;padding:12px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);display:flex;flex-direction:column;gap:6px}
  .plugin-block .workspaceList li strong{font-size:14px}
  .plugin-block .workspaceList li .path{font-size:12px;color:var(--muted);word-break:break-all}
  .plugin-block .workspaceList li .actions{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .plugin-block .workspaceList li.empty{font-size:13px;color:var(--muted);background:rgba(255,255,255,.02);border:1px dashed rgba(255,255,255,.12);text-align:center}
  .plugin-block .workspaceNotes{font-size:12px;color:var(--muted);display:flex;flex-direction:column;gap:4px}
  .plugin-block .workspaceNotes span{display:block}
  .plugin-block .pluginLibrary li.selected{outline:2px solid rgba(89,167,255,.6);outline-offset:2px}
  .plugin-block .rack-panel{display:flex;flex-direction:column;gap:14px;padding:16px;border-radius:12px;background:rgba(9,12,19,.92);border:1px solid rgba(255,255,255,.06);box-shadow:0 20px 36px rgba(0,0,0,.35)}
  .plugin-block .host-panel{margin-top:14px;display:flex;flex-direction:column;gap:12px;padding:18px;border-radius:12px;background:rgba(16,20,30,.9);border:1px solid rgba(89,167,255,.25);box-shadow:0 18px 30px rgba(0,0,0,.32)}
  .plugin-block .host-header{display:flex;align-items:flex-start;gap:12px;flex-wrap:wrap}
  .plugin-block .host-header h3{margin:0;font-size:17px}
  .plugin-block .host-actions{display:flex;gap:8px;margin-left:auto}
  .plugin-block .hostStatus{padding:10px;border-radius:8px;background:rgba(12,16,24,.75);border:1px solid rgba(255,255,255,.06)}
  .plugin-block .hostParameters{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px}
  .plugin-block .hostParameters li{padding:10px;border-radius:10px;background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.08);display:flex;flex-direction:column;gap:6px}
  .plugin-block .hostParamLabel{display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600}
  .plugin-block .hostParamLabel span{font-size:12px;color:var(--muted)}
  .plugin-block .hostWarnings{display:flex;flex-direction:column;gap:4px}
  .plugin-block .hostWarnings span{display:block;padding:6px 8px;border-radius:6px;background:rgba(255,139,139,.1);border:1px solid rgba(255,139,139,.3);font-size:12px;color:#ff9b9b}
  .plugin-block .instrument-panel{margin-top:12px;padding:20px;border-radius:14px;background:linear-gradient(160deg,rgba(8,12,20,.92),rgba(15,18,28,.94));border:1px solid rgba(89,167,255,.2);display:flex;flex-direction:column;gap:16px;box-shadow:0 20px 40px rgba(0,0,0,.35);position:relative;overflow:hidden;color:#f8fafc;--instrument-accent:#f97316;--instrument-surface:rgba(9,12,18,.78);--instrument-border:rgba(255,255,255,.08)}
  .plugin-block .instrument-panel::after{content:"";position:absolute;inset:0;pointer-events:none;background:radial-gradient(circle at 80% 10%,rgba(89,167,255,.18),transparent 55%)}
  .instrument-panel[hidden]{display:none !important}
  .instrument-header{display:flex;align-items:flex-start;gap:18px;flex-wrap:wrap;position:relative;z-index:1}
  .instrument-header h3{margin:0;font-size:18px}
  .instrument-header .instrument-subtitle{margin:2px 0 0;color:var(--muted)}
  .instrument-octave{margin-left:auto;display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(12,18,30,.75);border:1px solid rgba(255,255,255,.08)}
  .instrument-body{display:grid;gap:18px;grid-template-columns:minmax(280px,340px) minmax(260px,1fr);align-items:start;position:relative;z-index:1}
  @media (max-width:1100px){.instrument-body{grid-template-columns:1fr}}
  .instrument-visual{position:relative;overflow:hidden;border-radius:16px;border:1px solid var(--instrument-border);background:rgba(10,14,22,.7);box-shadow:0 16px 34px rgba(0,0,0,.32)}
  .instrument-artwork{width:100%;height:auto;display:block;opacity:.92}
  .instrument-ui-surface{position:absolute;inset:18px;display:flex;flex-direction:column;gap:12px;padding:12px;border-radius:12px;background:var(--instrument-surface);backdrop-filter:blur(4px);border:1px solid var(--instrument-border);overflow:auto}
  .instrument-controls{display:flex;flex-direction:column;gap:14px}
  .instrument-control-panel{border-radius:14px;padding:16px;background:var(--instrument-surface);border:1px solid var(--instrument-border);box-shadow:0 14px 30px rgba(0,0,0,.28);display:flex;flex-direction:column;gap:12px}
  .instrument-control-panel h4{margin:0;font-size:15px}
  .instrument-control-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(120px,1fr))}
  .instrument-control-row{display:flex;gap:12px;flex-wrap:wrap}
  .instrument-control{display:flex;flex-direction:column;gap:8px}
  .instrument-control .value{font-size:12px;color:var(--muted)}
  .instrument-control.knob{align-items:center;text-align:center}
  .instrument-control.knob input[type="range"]{width:100px}
  .instrument-keyboard{position:relative;display:flex;align-items:flex-end;gap:2px;padding:18px 14px;border-radius:14px;background:rgba(9,12,18,.9);border:1px solid var(--instrument-border);box-shadow:0 16px 30px rgba(0,0,0,.32);overflow-x:auto;z-index:1}
  .instrument-keyboard::-webkit-scrollbar{height:6px}
  .instrument-keyboard::-webkit-scrollbar-thumb{background:rgba(255,255,255,.1);border-radius:3px}
  .instrument-key{position:relative;min-width:42px;height:140px;border-radius:6px;border:1px solid rgba(0,0,0,.6);background:linear-gradient(180deg,#f5f7ff 0%,#d1d5e5 100%);color:#000;font-weight:600;display:flex;align-items:flex-end;justify-content:center;padding-bottom:10px;cursor:pointer;transition:transform .12s ease, box-shadow .12s ease}
  .instrument-key.black{background:linear-gradient(180deg,#1f2430 0%,#0f1218 100%);color:#fff;height:98px;margin-left:-18px;margin-right:-18px;z-index:2;border-color:#111}
  .instrument-key.active{transform:translateY(2px);box-shadow:0 8px 16px rgba(0,0,0,.35);background:linear-gradient(180deg,var(--instrument-accent) 0%, rgba(0,0,0,.45) 100%);color:#111;border-color:var(--instrument-accent)}
  .instrument-key.black.active{background:linear-gradient(180deg,var(--instrument-accent) 0%, rgba(0,0,0,.6) 100%);color:#000;border-color:var(--instrument-accent)}
  .instrument-footer{display:flex;flex-wrap:wrap;align-items:center;gap:12px;justify-content:space-between;padding:10px 0 0;margin-top:-6px;border-top:1px solid rgba(255,255,255,.08);position:relative;z-index:1}
  .instrument-velocity{display:flex;align-items:center;gap:8px}
  .plugin-block .rack-header{display:flex;flex-direction:column;gap:6px}
  .plugin-block .streamsContainer{display:flex;flex-direction:column;gap:14px}
  .plugin-block .rackStream{border-radius:12px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.03);padding:14px;display:flex;flex-direction:column;gap:12px;box-shadow:0 18px 32px rgba(0,0,0,.28)}
  .plugin-block .rackHead{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .plugin-block .rackHead h4{margin:0;font-size:16px}
  .plugin-block .rackButtons{margin-left:auto;display:flex;gap:8px}
  .plugin-block .laneWrap{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
  .plugin-block .laneCard{border-radius:10px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.2);padding:12px;display:flex;flex-direction:column;gap:10px}
  .plugin-block .laneHeader{display:flex;align-items:center;gap:8px}
  .plugin-block .laneHeader h5{margin:0;font-size:14px}
  .plugin-block .laneBadge{padding:2px 8px;border-radius:999px;background:rgba(89,167,255,.18);border:1px solid rgba(89,167,255,.35);font-size:11px;text-transform:uppercase;letter-spacing:.4px;color:var(--muted)}
  .plugin-block .slotList{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:8px}
  .plugin-block .slotList .slot{border-radius:8px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.05);padding:10px;display:flex;flex-direction:column;gap:6px}
  .plugin-block .slotList .slotTitle{display:flex;align-items:center;gap:6px;font-size:13px}
  .plugin-block .slotList .slot strong{font-size:12px;text-transform:uppercase;letter-spacing:.4px;color:var(--muted)}
  .plugin-block .slotList .slot .actions{display:flex;justify-content:flex-end}
  .plugin-block .slotList .empty{border:1px dashed rgba(255,255,255,.12);padding:12px;text-align:center;color:var(--muted);background:rgba(255,255,255,.02)}
  .plugin-block .laneControls{display:flex;justify-content:flex-end}
  .plugin-block .rack-log textarea{width:100%;min-height:140px;padding:10px;background:#090b10;color:inherit;border:1px solid rgba(89,167,255,.35);border-radius:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;font-size:12px;box-shadow:0 14px 28px rgba(0,0,0,.32) inset}
  body.theme-xp .plugin-block .rack-log textarea,
  body.theme-98 .plugin-block .rack-log textarea{background:#fff;color:#000;border:1px solid #7b7b7b}
  .scope{flex:1;min-width:220px;height:60px;background:#000;border:1px solid #666;border-radius:6px}
  .stream{background:var(--card);border:1px solid #555;border-radius:8px;padding:10px;margin:8px 0}
  .stream h3{margin:0 0 6px}
  .row{display:flex;align-items:center;gap:6px;flex-wrap:wrap;margin:6px 0}
  label{font-weight:600}
  .small{font-size:12px;color:var(--muted)}
  input[type="range"]{width:160px}
  .btn{padding:6px 10px;border:1px solid #666;background:#2a2a2a;color:#fff;border-radius:6px;cursor:pointer}
  .btn:hover{background:#333}
  .btn.on{outline:2px solid var(--accent)}
  select, input[type="number"], input[type="text"]{padding:4px 6px;background:var(--select);color:#fff;border:1px solid var(--select-border);border-radius:4px}
  option{background:var(--panel);color:#fff}
  .title{font-weight:800;letter-spacing:.3px}
  .spacer{flex:1}

  /* Vertical dropdown modules */
  .mods{display:flex;flex-direction:column;gap:8px;margin-top:6px}
  .mod{border:1px solid #555;border-radius:6px;overflow:hidden}
  .mod-hdr{display:flex;align-items:center;justify-content:space-between;background:#2a2a2a;padding:6px 10px;cursor:pointer}
  .mod-hdr .name{font-weight:700}
  .mod-hdr .carat{font-weight:800}
  .mod-body{display:none;padding:8px;background:#1a1a1a}
  .mod.open .mod-body{display:block}

  /* Spectrogram canvas */
  .spectro{width:100%;height:90px;background:#000;border:1px solid #666;border-radius:6px}

  /* Tooltip (native title works; add helper underline) */
  .hasTip{text-decoration:underline dotted #777; text-underline-offset: 2px;}

  /* Style mode overlay */
  .style-hover{outline:2px dashed #7bdcff !important; outline-offset:2px}
  .style-panel{position:fixed; right:10px; bottom:10px; background:#181818; border:1px solid #444; border-radius:8px; padding:10px; width:280px; display:none; z-index:99}
  .style-panel h4{margin:0 0 6px}
  .style-panel .row{margin:4px 0}

  /* === CodeChecker additions === */
  
  .style-on [contenteditable="true"]{ outline:1px dashed var(--accent); outline-offset:2px; cursor:text }

  
  .stream .aRow, .stream .bRow { align-items:center; gap:8px; }
  .btn.btn-xs{ padding:2px 6px; font-size:11px; line-height:1; }

  .dragHandle{opacity:.45; transition:opacity .15s}
  body.edit-on .dragHandle{opacity:1}
  body.edit-on .block{outline:2px dashed var(--accent); outline-offset:2px}
  body.edit-on #main{cursor:move}
  #modeToast{position:fixed; left:50%; top:12px; transform:translateX(-50%);
    background:#000c; color:#fff; padding:6px 10px; border:1px solid #444; border-radius:6px;
    font-size:12px; z-index:999; display:none}
  #stylePanel .subhdr{margin:8px 0 4px; font-weight:700; opacity:.8}
  #stylePanel .grid{display:grid; grid-template-columns:auto 1fr; gap:6px 10px; align-items:center}
  #stylePanel textarea{width:100%; min-height:90px; background:#0f0f0f; color:#ddd; border:1px solid #333; border-radius:6px; padding:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px}
  #stylePanel .row.wrap{flex-wrap:wrap}


  .placeholder{border:1px dashed var(--accent); border-radius:6px; margin:8px 0; height:40px; background:#0001}
  .draggingItem{opacity:.85; outline:2px dashed var(--accent)}


  /* Stabilize block/stream shape and initial sizing */
  .stream, .block { border-radius: 8px; overflow: hidden; height: auto; min-height: 0; }
  .mod { border-radius: 6px; overflow: hidden; }
  .mod .mod-body { display: none; }
  .mod.open .mod-body { display: block; }

  .mod + .mod { margin-top: 10px; }

/* Theme spacing tweaks */
.mods{ gap:14px !important; margin-top:10px !important; }
.mod .mod-body{ padding:12px 14px !important; }
.block{ padding:14px !important; }
.stream{ padding:12px !important; }

/* Stick toolbar to bottom for Win98/XP and reserve space */
body.theme-98 #toolbar, body.theme-xp #toolbar{ position:fixed; left:0; right:0; bottom:0; top:auto; z-index:1000; }
body.theme-98 #main, body.theme-xp #main{ padding-bottom:56px; }

/* Theme picker readability in 98/XP */
body.theme-98 #stylePreset, body.theme-xp #stylePreset{ background:#fff; color:#000; border:1px solid #7b7b7b; }
body.theme-98 #stylePreset option, body.theme-xp #stylePreset option{ color:#000; background:#fff; }

#desktopIcons{ position:fixed; top:12px; right:14px; z-index:0; pointer-events:none; display:none; flex-direction:column; gap:16px; }
.desktopIcon{ display:flex; flex-direction:column; align-items:center; font-family:Tahoma, 'MS Sans Serif', sans-serif; font-size:12px; }
.desktopIcon .ico{ width:48px; height:48px; image-rendering:pixelated; background-size:48px 48px; background-repeat:no-repeat;
  background-image: linear-gradient(#fff,#ddd); border:1px solid #0003; border-radius:6px; }
.desktopIcon .title{ margin-top:4px; color:#000; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff; }
body.theme-xp #desktopIcons, body.theme-98 #desktopIcons{ display:flex; }

/* === Custom slider imagery (track/thumb) === */
:root{
  --slider-track-img: none;
  --slider-thumb-img: none;
  --slider-track-scale: 1;
  --slider-thumb-scale: 1;
  --slider-track-rotate: 0deg;
  --slider-thumb-rotate: 0deg;
}
input[type="range"]{ -webkit-appearance:none; appearance:none; background:transparent; }
input[type="range"]::-webkit-slider-runnable-track{ height:10px; background: var(--panel); }
input[type="range"]::before{ content:""; display:block; height:10px; background-image: var(--slider-track-img);
  background-size: contain; background-repeat:no-repeat; background-position:center;
  transform: rotate(var(--slider-track-rotate)) scale(var(--slider-track-scale)); }
input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; border:1px solid #0008; border-radius:2px;
  background: var(--card); background-image: var(--slider-thumb-img); background-size:contain; background-repeat:no-repeat; background-position:center;
  transform: rotate(var(--slider-thumb-rotate)) scale(var(--slider-thumb-scale)); }
input[type="range"]::-moz-range-track{ height:10px; background: var(--panel); }
input[type="range"]::-moz-range-thumb{ width:16px; height:16px; border:1px solid #0008; border-radius:2px; background: var(--card);
  background-image: var(--slider-thumb-img); background-size:contain; background-repeat:no-repeat; background-position:center;
  transform: rotate(var(--slider-thumb-rotate)) scale(var(--slider-thumb-scale)); }

/* Theme picker readability */
body.theme-98 #stylePreset, body.theme-xp #stylePreset{ background:#fff; color:#000; border:1px solid #7b7b7b; }
body.theme-98 #stylePreset option, body.theme-xp #stylePreset option{ color:#000; background:#fff; }

/* === Windows XP look (xp.css-inspired) === */
body.theme-xp{ background-image: var(--xp-wallpaper); background-size: cover; background-position:center;  image-rendering:pixelated; font-family: Tahoma, Verdana, sans-serif; background: var(--xp-wallpaper), linear-gradient(#6aa6ff 0 50%, #4c82f4 55%, #99d86d 60%, #56ad34 100%) fixed; }
body.theme-xp .mod{ border:1px solid #6c8ed0; border-radius:2px; background:linear-gradient(#f7faff 0%, #e0ebff 55%, #d4e2ff 100%); box-shadow:0 1px 0 rgba(255,255,255,.7) inset; }
body.theme-xp .mod-hdr{ background: linear-gradient(180deg,#5c8fff 0%,#3f73e2 75%); color:#fff; border-bottom:1px solid #355db9; border-radius:2px 2px 0 0; text-shadow:0 1px 0 rgba(0,0,0,.35); }
body.theme-xp .btn{ border-radius:2px; background: linear-gradient(#f5f9ff 0%, #d4e4ff 100%); border:1px solid #6b8ccc; color:#13336d; box-shadow:0 1px 0 rgba(255,255,255,.8) inset, 0 1px 2px rgba(20,48,125,.18); }
body.theme-xp .btn:hover{ background:linear-gradient(#ffffff 0%, #dcebff 100%); }
body.theme-xp .btn:active{ background: linear-gradient(#cddfff,#b9d0fb); color:#0a2c66; box-shadow: inset 0 1px 2px rgba(0,0,0,.18); }
body.theme-xp select, body.theme-xp input[type="text"], body.theme-xp input[type="number"]{ border:1px solid #6b8ccc; background:linear-gradient(#ffffff,#edf3ff); border-radius:3px; color:#123169; box-shadow:0 1px 0 rgba(255,255,255,.7) inset; }
body.theme-xp input[type="range"]::-webkit-slider-thumb{ width:14px; height:14px; border-radius:2px; background:linear-gradient(#f6f9ff,#d7e6ff); border:1px solid #5c7ed1; }
body.theme-xp input[type="range"]::-moz-range-thumb{ width:14px; height:14px; border-radius:2px; background:linear-gradient(#f6f9ff,#d7e6ff); border:1px solid #5c7ed1; }

/* ====================== XP fidelity pack ====================== */

/* Taskbar (toolbar) */
body.theme-xp #toolbar{
  position: fixed; left:0; right:0; bottom:0; height:32px; z-index:1000;
  background: linear-gradient( to bottom,
    #4a82e4 0%, /* Darker blue at the top */
    #3f72d8 10%, /* Smoother blend to the middle */
    #2562c1 50%, /* Mid-tone blue */
    #3d71d3 90%, /* Slight brightening toward the bottom */
    #3d71d3 100% /* Same color at the very bottom */);
  border-top: 1px solid #183d92;
  display: flex; align-items: center; gap: 8px; padding: 2px 6px;
  image-rendering: pixelated;
}
body.theme-xp #main{ padding-bottom: 44px; } /* reserve space */

/* Start button */
body.theme-xp #xpStart{
  display:inline-flex; align-items:center; gap:6px; height:28px;
  padding: 0 10px 0 8px; cursor: default; user-select:none;
  color:#fff; font: bold 13px Tahoma, Verdana, sans-serif;
  background: linear-gradient(#5fdc78,#3ab34f);
  border: 1px solid #1b6a29; border-radius: 6px;
  box-shadow: inset 0 1px 0 #93f0a7, inset 0 -1px 0 #2b8e3d, 0 1px 0 rgba(0,0,0,.2);
}
body.theme-xp #xpStart .xpLogo{
  width:16px; height:16px; display:inline-block; background-repeat:no-repeat; background-size:100% 100%;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><rect x='0' y='0' width='7' height='7' fill='%23f35325'/><rect x='9' y='0' width='7' height='7' fill='%2380cc28'/><rect x='0' y='9' width='7' height='7' fill='%2305a6f0'/><rect x='9' y='9' width='7' height='7' fill='%23ffba08'/></svg>");
}

/* Push toolbar content after Start */
body.theme-xp #toolbarInner{ display:flex; align-items:center; gap:8px; flex:1; overflow:hidden; }

/* Window (module) header controls */
body.theme-xp .mod-hdr{ position: relative; padding-right: 64px; }
body.theme-xp .win-ctl{ position:absolute; right:6px; top:4px; display:flex; gap:4px; }
body.theme-xp .win-ctl .btnctl{
  width:18px; height:18px; border:1px solid #6b8ccc; border-radius:2px; background:#e7edf9;
  box-shadow: inset 0 1px 0 #fff;
}
body.theme-xp .win-ctl .btnctl:hover{ background:#fff; }
body.theme-xp .win-ctl .min{ background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='18' height='18'><rect x='4' y='12' width='10' height='2' fill='%23000'/></svg>"); background-repeat:no-repeat; background-position:center; }
body.theme-xp .win-ctl .max{ background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='18' height='18'><rect x='4' y='4' width='10' height='10' fill='none' stroke='%23000'/></svg>"); background-repeat:no-repeat; background-position:center; }
body.theme-xp .win-ctl .cls{ background:#ff5a5a; background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='18' height='18'><path d='M5 5 L13 13 M13 5 L5 13' stroke='%23fff' stroke-width='2' /></svg>"); background-repeat:no-repeat; background-position:center; }

/* Maximize behavior */
body.theme-xp .mod.maximized{ position:relative; z-index:5; }
body.theme-xp .mod.maximized .mod-body{ max-height: 60vh; overflow:auto; }

/* Scrollbars (WebKit) */
body.theme-xp *::-webkit-scrollbar{ width:14px; height:14px; }
body.theme-xp *::-webkit-scrollbar-track{ background: #e7edf9; }
body.theme-xp *::-webkit-scrollbar-thumb{ background: linear-gradient(#fff,#d6e4ff); border:1px solid #6b8ccc; border-radius:2px; }
body.theme-xp *::-webkit-scrollbar-button{ background: #d6e4ff; border:1px solid #6b8ccc; }
body.theme-xp *::-webkit-scrollbar-button:vertical:decrement{ background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14'><polygon points='7,3 11,9 3,9' fill='%23000'/></svg>"); background-repeat:no-repeat; background-position:center; }
body.theme-xp *::-webkit-scrollbar-button:vertical:increment{ background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14'><polygon points='3,5 11,5 7,11' fill='%23000'/></svg>"); background-repeat:no-repeat; background-position:center; }
body.theme-xp *::-webkit-scrollbar-button:horizontal:decrement{ background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14'><polygon points='3,7 9,3 9,11' fill='%23000'/></svg>"); background-repeat:no-repeat; background-position:center; }
body.theme-xp *::-webkit-scrollbar-button:horizontal:increment{ background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14'><polygon points='11,7 5,3 5,11' fill='%23000'/></svg>"); background-repeat:no-repeat; background-position:center; }

/* Checkboxes / Radios (bitmap-ish) */
body.theme-xp input[type="checkbox"]{
  appearance:none; -webkit-appearance:none; width:13px; height:13px; border:1px solid #6b8ccc; border-radius:2px;
  background:#fff; box-shadow: inset 0 1px 0 #fff;
  vertical-align:middle; margin-right:6px;
}
body.theme-xp input[type="checkbox"]:checked{
  background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='13' height='13'><path d='M2 7 L5 10 L11 3' stroke='%230a5bd3' stroke-width='2' fill='none'/></svg>");
  background-repeat:no-repeat; background-position:center;
}
body.theme-xp input[type="radio"]{
  appearance:none; -webkit-appearance:none; width:13px; height:13px; border:1px solid #6b8ccc; border-radius:50%;
  background:#fff; box-shadow: inset 0 1px 0 #fff;
  vertical-align:middle; margin-right:6px;
}
body.theme-xp input[type="radio"]:checked{
  background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='13' height='13'><circle cx='6.5' cy='6.5' r='3' fill='%230a5bd3'/></svg>");
  background-repeat:no-repeat; background-position:center;
}

/* Toolbar scaffold & positions */
#toolbarInner{ display:flex; align-items:center; gap:8px; flex:1; overflow:hidden; }
#taskButtons{ display:flex; gap:6px; align-items:center; overflow-x:auto; }
#tray{ margin-left:auto; display:flex; gap:8px; align-items:center; padding:0 8px; }
#clock{ font:12px Tahoma, Verdana, sans-serif; opacity:.9; }
body:not(.theme-xp):not(.theme-98) #toolbar{ position:sticky; top:0; left:0; right:0; z-index:1000; }
body.theme-98 #toolbar, body.theme-xp #toolbar{ position:fixed; bottom:0; left:0; right:0; top:auto; z-index:1000; }
body.theme-98 #main, body.theme-xp #main{ padding-bottom:56px; }

/* Edit-only: window controls + closeX */
.win-ctl, .mod-hdr .closeX{ display:none !important; }
.edit-on .win-ctl, .edit-on .mod-hdr .closeX{ display:flex !important; }

/* Theme picker menu readability in 98/XP */
body.theme-98 #themePicker, body.theme-98 #themePicker option{ background:#fff; color:#000; border:1px solid #7b7b7b; }
body.theme-xp #themePicker, body.theme-xp #themePicker option{ background:#fff; color:#000; border:1px solid #93a4bd; }
</style>

<style>


/* ===== Windows 98 theme (scoped) ===== */
body.theme-98{ background:#008080 !important; background:#008080 !important;
  /* canonical Win98 colors */
  --bg:#c0c0c0; --panel:#c0c0c0; --card:#c0c0c0; --text:#000; --muted:#111; --accent:#000080;
  --select:#000080; --select-border:#7b7b7b;
  font-family: "MS Sans Serif", Tahoma, Verdana, Arial, sans-serif;
  image-rendering: pixelated;
}
/* Bars / containers */
body.theme-98 #toolbar{
  background:#c0c0c0;
  border-top:2px solid #7b7b7b; border-left:2px solid #7b7b7b;
  border-bottom:2px solid #fff;  border-right:2px solid #fff;
  padding:2px 4px;
}
body.theme-98 .stream, body.theme-98 .block, body.theme-98 .mod{
  background:#c0c0c0; color:#000;
  border:2px solid; border-color:#fff #7b7b7b #7b7b7b #fff; /* raised */
  border-radius:0;
  box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #dfdfdf;
}
/* Module header (title bar) */
body.theme-98 .mod-hdr{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  background:#000080; color:#fff; padding:3px 6px;
  font-weight:bold;
}
body.theme-98 .mod-hdr .name{ color:#fff; }
body.theme-98 .mod-hdr .carat{ color:#fff; opacity:.95; }

/* Buttons */
body.theme-98 .btn{
  background:#c0c0c0; color:#000; border-radius:0;
  border:2px solid; border-color:#fff #7b7b7b #7b7b7b #fff;
  box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #dfdfdf;
  padding:2px 8px; line-height:1.1;
}
body.theme-98 .btn:active{
  border-color:#7b7b7b #fff #fff #7b7b7b;
  box-shadow: inset 1px 1px 0 #000, inset -1px -1px 0 #dfdfdf;
}

/* Checkboxes & radios */
body.theme-98 input[type="checkbox"], body.theme-98 input[type="radio"]{
  appearance:none; -webkit-appearance:none; outline:none; margin:0 6px 0 0;
  width:13px; height:13px; background:#fff;
  border:2px solid; border-color:#7b7b7b #fff #fff #7b7b7b;
  box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #dfdfdf;
  vertical-align:middle;
}
body.theme-98 input[type="checkbox"]:checked{ background:
  linear-gradient(45deg, transparent 45%, #000 45% 55%, transparent 55%),
  linear-gradient(-45deg, transparent 45%, #000 45% 55%, transparent 55%),
  #fff;
}
body.theme-98 input[type="radio"]{ border-radius:50%; }
body.theme-98 input[type="radio"]:checked{
  background:
    radial-gradient(circle at 50% 50%, #000 0 3px, transparent 3px) #fff;
}

/* Text inputs & selects */
body.theme-98 select, body.theme-98 input[type="number"], body.theme-98 input[type="text"]{
  background:#fff; color:#000; border-radius:0; padding:2px 4px;
  border:2px solid; border-color:#7b7b7b #fff #fff #7b7b7b;
  box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #dfdfdf;
}

/* Sliders */
body.theme-98 input[type="range"]{
  -webkit-appearance:none; appearance:none; height:16px; background:#c0c0c0;
  border:2px solid; border-color:#fff #7b7b7b #7b7b7b #fff;
}
body.theme-98 input[type="range"]::-webkit-slider-runnable-track{
  height:12px; background:#c0c0c0;
}
body.theme-98 input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none; width:16px; height:16px; margin-top:-2px;
  background:#c0c0c0; border:2px solid; border-radius:0;
  border-color:#7b7b7b #fff #fff #7b7b7b;
  box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #dfdfdf;
}

/* Canvases */
body.theme-98 .spectro, body.theme-98 .scope{
  border:2px solid; border-color:#7b7b7b #fff #fff #7b7b7b; border-radius:0;
}

/* Scrollbars (webkit-based) */
body.theme-98 *::-webkit-scrollbar{ width:14px; height:14px; }
body.theme-98 *::-webkit-scrollbar-thumb{
  background:#c0c0c0; border:2px solid; border-color:#7b7b7b #fff #fff #7b7b7b;
  box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #dfdfdf;
}


/* ===== Windows XP theme (scoped) ===== */
body.theme-xp{ background-image: var(--xp-wallpaper); background-size: cover; background-position:center;
  /* canonical XP-ish colors */
  --bg:#1f4fd0; --panel:#d0e2ff; --card:#e4efff; --text:#00174a; --muted:#274276; --accent:#2b63e6;
  --select:#f7fbff; --select-border:#6e8ed1;
  font-family: Tahoma, "Segoe UI", Verdana, Arial, sans-serif;
  background: linear-gradient(#4b85ff, #1f4fd0) fixed;
}
body.theme-xp #main{
  background: linear-gradient(180deg, rgba(255,255,255,.92) 0%, rgba(205,226,255,.94) 35%, rgba(178,210,255,.96) 100%);
}
body.theme-xp #toolbar{
  background: linear-gradient(#f4f8ff 0%, #d7e6ff 100%); border-bottom:1px solid #6e8ed1; padding:6px 8px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.9);
}
body.theme-xp .stream, body.theme-xp .block{
  background: linear-gradient(180deg, rgba(249,252,255,1) 0%, rgba(221,234,255,1) 48%, rgba(199,219,255,1) 100%);
  border-radius:8px;
  border:1px solid #6e8ed1; box-shadow: 0 1px 0 rgba(255,255,255,.8) inset, 0 1px 2px rgba(23,47,128,.2);
}
body.theme-xp .mod{
  border-radius:8px; border:1px solid #6e8ed1; background:linear-gradient(#f4f8ff,#dce8ff);
}
body.theme-xp .mod-hdr{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  background: linear-gradient(180deg,#5e91ff,#2f64dd); color:#fff; padding:6px 10px; border-bottom:1px solid #264fb3; border-radius:8px 8px 0 0;
  font-weight:bold; text-shadow:0 1px 0 rgba(0,0,0,.35);
}
body.theme-xp .mod-hdr .name,
body.theme-xp .mod-hdr .carat{ color:#fff; }
body.theme-xp .mod-body{ background:linear-gradient(#f9fbff,#e7f0ff); }
body.theme-xp .btn{
  background: linear-gradient(#f7faff, #d4e3ff); color:#123169; border:1px solid #6e8ed1; border-radius:6px;
  box-shadow: 0 1px 0 rgba(255,255,255,.85) inset, 0 1px 2px rgba(21,47,120,.18);
  padding:4px 10px;
}
body.theme-xp .btn:hover{ background: linear-gradient(#ffffff, #dcebff); }
body.theme-xp .btn:active{ background: linear-gradient(#cddfff, #b7d0fb); color:#0a2c66; box-shadow: inset 0 1px 2px rgba(0,0,0,.18); }

/* Checkboxes & radios */
body.theme-xp input[type="checkbox"], body.theme-xp input[type="radio"]{
  appearance:none; -webkit-appearance:none; outline:none; margin:0 6px 0 0;
  width:14px; height:14px; background:#fff; border-radius:3px;
  border:1px solid #93a4bd; box-shadow: 0 1px 0 #fff inset;
}
body.theme-xp input[type="checkbox"]:checked{ background:
  linear-gradient(45deg, transparent 45%, #0a5bd3 45% 55%, transparent 55%),
  linear-gradient(-45deg, transparent 45%, #0a5bd3 45% 55%, transparent 55%),
  #fff; }
body.theme-xp input[type="radio"]{ border-radius:50%; }
body.theme-xp input[type="radio"]:checked{
  background: radial-gradient(circle at 50% 50%, #0a5bd3 0 4px, transparent 4px) #fff;
}

/* Sliders */
body.theme-xp input[type="range"]{
  -webkit-appearance:none; appearance:none; height:6px; background:#c3d4f7; border-radius:4px; border:1px solid #93a4bd;
}
body.theme-xp input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:#c3d4f7; border-radius:4px; }
body.theme-xp input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none; width:16px; height:16px; margin-top:-6px;
  background:linear-gradient(#fff, #e6eefb); border:1px solid #93a4bd; border-radius:50%;
  box-shadow: 0 1px 0 #fff inset, 0 0 2px rgba(0,0,0,.25);
}

/* Inputs */
body.theme-xp select, body.theme-xp input[type="number"], body.theme-xp input[type="text"]{
  background:linear-gradient(#ffffff,#edf3ff); color:#123169; border:1px solid #6e8ed1; border-radius:6px; padding:4px 6px;
  box-shadow: 0 1px 0 rgba(255,255,255,.85) inset;
}

/* Canvases */
body.theme-xp .spectro, body.theme-xp .scope{
  border:1px solid #93a4bd; border-radius:8px;
}

/* Scrollbars */
body.theme-xp *::-webkit-scrollbar{ width:12px; height:12px; }
body.theme-xp *::-webkit-scrollbar-thumb{
  background: linear-gradient(#fff,#e6eefb); border:1px solid #93a4bd; border-radius:8px;
}

</style>

<style id="nob64-guard">
:root{ --xp-wallpaper: none !important; }
body.theme-xp{ background-image: none !important; }
</style>

<style id="theme-fixes-v4">
.style-panel{background:#f6f6f6 !important; color:#111 !important; border:1px solid #8aa8d8 !important;}
.style-panel input,.style-panel select,.style-panel textarea{background:#fff !important; color:#000 !important; border:1px solid #7b7b7b !important;}
body.theme-xp, body.theme-xp #app, body.theme-xp #main, body.theme-xp .workspace{
  background: linear-gradient(#eaf2ff, #d6e6ff) !important;
  color: var(--text,#000);
}
body.theme-98, body.theme-98 #app, body.theme-98 #main, body.theme-98 .workspace{
  background: #008080 !important; color: var(--text,#000);
}
body:not(.theme-xp):not(.theme-98),
body:not(.theme-xp):not(.theme-98) #app,
body:not(.theme-xp):not(.theme-98) #main,
body:not(.theme-xp):not(.theme-98) .workspace{
  background: var(--bg, #1b1b1b) !important;
}
body.theme-xp{--bg:#dfe8f6;--panel:#e9f0fb;--card:#f6f9ff;--text:#000;--muted:#333;--accent:#3a6ea5;--select:#fff;--select-border:#8aa8d8;}
body.theme-98{--bg:#008080;--panel:#c0c0c0;--card:#dfdfdf;--text:#000;--muted:#111;--accent:#0000aa;--select:#fff;--select-border:#7b7b7b;}
body.theme-xp  .card, body.theme-xp  .stream, body.theme-xp  .mod-body,
body.theme-98 .card, body.theme-98 .stream, body.theme-98 .mod-body{
  background: var(--card,#f6f9ff) !important; color: var(--text,#000) !important;
}
body.theme-98 select, body.theme-xp select{background:#fff; color:#000; border:1px solid var(--select-border,#7b7b7b);}
</style></head>
<body>
<div id="app">
  <div id="toolbar">
      <span class="title">Noisetown Ultimate</span>
    <button id="startAudio" class="btn">🎵 Start Audio</button>
    <button id="addBlock" class="btn">➕ Add Block</button>
    <button id="editToggle" class="btn" aria-pressed="false">✏️ Edit: OFF</button>
    <button id="styleMode" class="btn" aria-pressed="false">🎨 Style Mode: OFF</button>
    
    <select id="themePicker" class="btn"><option value="flat">Theme: Flat (Default)</option><option value="win98">Theme: Windows 98</option><option value="winxp">Theme: Windows XP</option></select>
<div class="spacer"></div>
    <button id="saveSession" class="btn">💾 Save</button>
    <button id="savePreset" class="btn">💾 Save Preset+Audio</button>
    <input id="loadFile" type="file" accept="application/json" style="display:none">
    <button id="loadSession" class="btn">📂 Load</button>
    <input id="loadPresetFile" type="file" accept="application/json" style="display:none">
    <button id="loadPreset" class="btn">📂 Load Preset</button>
  </div>
  <div id="main"></div>
  <div id="modeToast" role="status" aria-live="polite"></div>
</div>

<!-- Style panel -->
<div id="stylePanel" class="style-panel">
  <h4>Style Painter</h4>
  <div class="row">
    <label>Preset</label>
    <select id="stylePreset">
      <option value="">Custom…</option>
      <option value="bevel">Beveled</option>
      <option value="shadow">Shadow</option>
      <option value="soft">Soft Card</option>
      <option value="glow">Glow</option>
      <option value="flat">Flat</option>
      </select>
  </div>
  <div class="row">
    <label>Radius</label><input id="styRadius" type="range" min="0" max="20" step="1" value="8">
  </div>
  <div class="row">
    <label>Shadow</label><input id="styShadow" type="range" min="0" max="40" step="1" value="12">
  </div>
  <div class="row">
    <label>Apply to</label>
    <select id="styScope">
      <option value="element">This element</option>
      <option value="stream">This stream</option>
      <option value="block">This block</option>
      <option value="global">Global</option>
    </select>
  </div>
  <div class="row">
    <button id="styApply" class="btn">Apply</button>
    <button id="styResetTheme" class="btn">Reset</button>
    <button id="stySaveTheme" class="btn" style="margin-left:auto">Save Theme JSON</button>
  </div>
  <div class="small">Hover to select an element. Click to focus. Adjust, then Apply.</div>
</div>

<script>
  /* --- Granular Worklet Source --- */
  ;(function ensureGranularWorklet(){
    if(self._granularWorkletReady) return;
    const code = `
      class GranularProcessor extends AudioWorkletProcessor {
        static get parameterDescriptors(){
          return [
            { name:'rate', defaultValue:1, minValue:0.25, maxValue:4 },
            { name:'transpose', defaultValue:0, minValue:-12, maxValue:12 },
            { name:'grainSize', defaultValue:0.08, minValue:0.02, maxValue:0.2 },
            { name:'overlap', defaultValue:0.6, minValue:0.1, maxValue:0.95 },
            { name:'gate', defaultValue:0, minValue:0, maxValue:1 }
          ];
        }
        constructor(){
          super();
          this.bufL = null; this.bufR = null;
          this.len = 0; this.pos = 0; this.loop = true; this.reverse = false;
          this.sr = sampleRate;
          this._win = {}; // Hann cache
          this.port.onmessage = (e)=>{
            const d = e.data||{};
            if(d.type==='setBuffer'){
              this.bufL = d.L || null; this.bufR = d.R || null;
              this.len = (this.bufL && this.bufL.length)|0; this.pos = Math.max(0, Math.min(this.pos, this.len-1));
            }else if(d.type==='seek'){
              const t = d.time||0; this.pos = Math.max(0, Math.min(Math.floor(t*this.sr), this.len-1));
            }else if(d.type==='params'){
              if(typeof d.loop==='boolean') this.loop = d.loop;
              if(typeof d.reverse==='boolean') this.reverse = d.reverse;
            }
          };
        }
        hann(n){
          if(this._win[n]) return this._win[n];
          const w = new Float32Array(n); for(let i=0;i<n;i++) w[i]=0.5*(1-Math.cos(2*Math.PI*i/(n-1)));
          return (this._win[n]=w);
        }
        process(inputs, outputs, params){
          const outL = outputs[0][0]; const outR = outputs[0][1] || outputs[0][0];
          outL.fill(0); outR.fill(0);
          if(!this.bufL || this.len<=1) return true;

          const gate = (params.gate.length>1?params.gate[0]:params.gate[0])|0;
          if(!gate){ return true; } // silent when gate=0 (not playing)

          const rate = params.rate.length>1 ? params.rate[0] : params.rate[0];
          const semi = params.transpose.length>1 ? params.transpose[0] : params.transpose[0];
          const grainSec = params.grainSize[0];
          const ov = params.overlap[0];

          const pitch = Math.pow(2, semi/12);
          const grainLen = Math.max(32, Math.floor(grainSec * this.sr));
          const hop = Math.max(1, Math.floor(grainLen * (1-ov)));
          const win = this.hann(grainLen);

          // Simple 1-grain OLA per block (cheap & stable)
          for(let i=0; i<outL.length; i++){
            // compute source index for this output sample
            // time-stretch: advance read head by 'rate' every 'hop' samples
            if(i % hop === 0){
              const step = (this.reverse ? -1 : 1) * Math.max(0.0001, rate) * hop;
              this.pos += step;
              if(this.loop){
                while(this.pos < 0) this.pos += this.len;
                while(this.pos >= this.len) this.pos -= this.len;
              }else{
                if(this.pos < 0 || this.pos >= this.len){ this.pos = Math.max(0, Math.min(this.pos, this.len-1)); }
              }
            }

            // pitch: resample within the grain
            const gphase = (i % grainLen) / grainLen;
            const srcIndex = this.pos + (gphase * grainLen) * (this.reverse ? -pitch : pitch);
            let j = Math.floor(srcIndex);
            let a = srcIndex - j;

            if(this.loop){
              while(j < 0) j += this.len;
              while(j >= this.len) j -= this.len;
            }else{
              if(j < 0){ j = 0; a = 0; }
              if(j >= this.len-1){ j = this.len-2; a = 1; }
            }

            const l0 = this.bufL[j] || 0, l1 = this.bufL[(j+1) % this.len] || 0;
            const r0 = (this.bufR?this.bufR[j]:l0), r1 = (this.bufR?this.bufR[(j+1)%this.len]:l1);
            const w = win[Math.floor(gphase*(win.length-1))];
            const sL = (l0 + (l1-l0)*a) * w;
            const sR = (r0 + (r1-r0)*a) * w;

            outL[i] += sL;
            outR[i] += sR;
          }
          return true;
        }
      }
      registerProcessor('granular-processor', GranularProcessor);
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    self._granularWorkletURL = URL.createObjectURL(blob);
    self._granularWorkletReady = true;
  })();

(function(){
  // ===== Utilities =====

  function applyIndepRouting(sample, gA, gB){
    try{
      if(sample.indepTP){
        if(!sample.A.proc) sample.A.proc = createGranularNodeFor(sample.A);
        if(!sample.B.proc) sample.B.proc = createGranularNodeFor(sample.B);
        if(sample.A.proc){ try{ sample.A.proc.disconnect(); }catch(e){} sample.A.proc.connect(gA); }
        if(sample.B.proc){ try{ sample.B.proc.disconnect(); }catch(e){} sample.B.proc.connect(gB); }
      }else{
        try{ if(sample.A.proc) sample.A.proc.disconnect(); }catch(e){}
        try{ if(sample.B.proc) sample.B.proc.disconnect(); }catch(e){}
      }
    }catch(e){ console.warn('applyIndepRouting', e); }
  }

  function createGranularNodeFor(side){
    if(!ACTX || !ACTX.audioWorklet) return null;
    try{
      const node = new AudioWorkletNode(ACTX, 'granular-processor', { numberOfInputs:0, numberOfOutputs:1, outputChannelCount:[2] });
      node.parameters.get('rate').value = 1;
      node.parameters.get('transpose').value = 0;
      node.parameters.get('grainSize').value = 0.08;
      node.parameters.get('overlap').value = 0.6;
      node.parameters.get('gate').value = 0;
      // send buffer if available
      if(side && side.buf){
        const L = side.buf.getChannelData(0).slice();
        const R = (side.buf.numberOfChannels>1) ? side.buf.getChannelData(1).slice() : null;
        node.port.postMessage({type:'setBuffer', L, R});
      }
      return node;
    }catch(e){ console.warn('Granular node create failed', e); return null; }
  }
  function clamp01(x){ return x<0?0:(x>1?1:x); }
  function makeReversedBuffer(buf){
    if(!buf) return null;
    const out = new AudioBuffer({length: buf.length, numberOfChannels: buf.numberOfChannels, sampleRate: buf.sampleRate});
    for(let ch=0; ch<buf.numberOfChannels; ch++){
      const src = buf.getChannelData(ch);
      const dst = out.getChannelData(ch);
      for(let i=0, n=src.length; i<n; i++) dst[i] = src[n-1-i];
    }
    return out;
  }

  const GRID = 16; // snap size (px)
  const LFO_TICKS = [];
  let LFO_LOOP_STARTED = false;
  function ensureLfoLoop(){
    if(LFO_LOOP_STARTED) return;
    LFO_LOOP_STARTED = true;
    const loop = (ts)=>{ for(const fn of LFO_TICKS){ try{ fn(ts); }catch(e){} } requestAnimationFrame(loop); };
    requestAnimationFrame(loop);
  }

  const qs = (sel, root=document)=>root.querySelector(sel);
  const qsa = (sel, root=document)=>Array.from(root.querySelectorAll(sel));
  const ce = (tag, cls)=>{ const el=document.createElement(tag); if(cls) el.className=cls; return el; };
  const fmtPan = v => (Math.abs(v)<0.01 ? 'C' : (v<0?`L ${Math.round(-v*100)}%`:`R ${Math.round(v*100)}%`));
  const valueToFreq = x => 300 * Math.pow(20000/300, x); // 0..1 -> 300..20000 Hz
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
  const tip = (el, text)=>{ el.setAttribute('title', text); el.classList.add('hasTip'); };

  // ===== Audio Master Graph =====
  let ACTX = null;
  const MASTER = { pre:null, limiter:null };

  
  async function loadGranularWorklet(){
    try{
      ensureGranularWorklet();
      await ACTX.audioWorklet.addModule(self._granularWorkletURL);
    }catch(e){ console.warn('Granular worklet failed to load', e); }
  }
function bootAudio(){
    if(ACTX) return;
    ACTX = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive' });

    MASTER.pre = ACTX.createGain(); MASTER.pre.gain.value = 1.0;
    MASTER.limiter = ACTX.createDynamicsCompressor();
    MASTER.limiter.threshold.value = -6; MASTER.limiter.knee.value = 6; MASTER.limiter.ratio.value = 6;
    MASTER.limiter.attack.value = 0.003; MASTER.limiter.release.value = 0.25;

    MASTER.pre.connect(MASTER.limiter);
    MASTER.limiter.connect(ACTX.destination);
  }

  // ===== Blocks & Streams =====
  const main = qs('#main');
  const blocks = [];        // { el, bus, analyser, cvs, ctx, streams:[] }
  const streamSpectros = []; // for spectrogram draw loop

  let blockCount = 0;

  const pluginState = { status: null, selected: null };
  const hostState = { status: null, busy: false };
  const LANE_KEYS = ['A', 'B'];

  const isPluginBlock = (el)=> !!(el && el.dataset && el.dataset.role === 'plugin-rack');

  function ensurePluginRack(){
    if(qs('#pluginRackBlock')) return null;
    const blockEl = ce('div','block plugin-block');
    blockEl.id = 'pluginRackBlock';
    blockEl.dataset.role = 'plugin-rack';
    blockEl.innerHTML = `
      <div class="studio-header">
        <h2><span class="dragHandle" style="cursor:move">⣿</span> Plugin Rack</h2>
        <span class="tagline">Route native plugins directly alongside your Noisetown sessions.</span>
        <span class="status-text">Library pending…</span>
      </div>
      <div class="studio-grid plugin-layout">
        <section class="workspace-panel">
          <header>
            <h3>Plugin Library</h3>
            <button class="btn refreshPlugins">🔄 Refresh</button>
          </header>
          <p class="workspaceHint">Drop VST, VST3, Audio Unit, or mc.svt plugins into this folder.</p>
          <div class="workspacePathRow">
            <code class="workspacePath">Not available</code>
            <button class="btn copyWorkspace">📋 Copy Path</button>
          </div>
          <ul class="workspaceList pluginLibrary"></ul>
          <div class="workspaceNotes"></div>
        </section>
        <section class="rack-panel">
          <header class="rack-header">
            <h3>Streams &amp; Lanes</h3>
            <div class="selectedPlugin small">Select a plugin to assign it to a lane.</div>
          </header>
          <div class="streamsContainer"></div>
          <div class="rackNotes small"></div>
        </section>
      </div>
      <section class="host-panel" aria-live="polite">
        <header class="host-header">
          <div class="host-title">
            <h3>Live VST Host</h3>
            <p class="host-subtitle small">Powered by Flutter VST3 toolkit</p>
          </div>
          <div class="host-actions">
            <button class="btn hostLoad" disabled>⬆️ Load Selected</button>
            <button class="btn hostUnload" disabled>⏏ Unload</button>
            <button class="btn hostPreview" disabled>▶️ Preview</button>
          </div>
        </header>
        <div class="hostStatus small">Toolkit status pending…</div>
        <ul class="hostParameters"></ul>
        <div class="hostWarnings"></div>
      </section>
      <section class="instrument-panel" aria-live="polite" hidden>
        <header class="instrument-header">
          <div>
            <h3 class="instrument-title">Digital Instrument</h3>
            <p class="instrument-subtitle small">Load an instrument plugin to unlock performance controls.</p>
          </div>
          <div class="instrument-octave">
            <button class="btn instrument-octave-down" type="button" aria-label="Lower octave">◀ Oct</button>
            <span class="instrument-octave-label">Octave 4</span>
            <button class="btn instrument-octave-up" type="button" aria-label="Raise octave">Oct ▶</button>
          </div>
        </header>
        <div class="instrument-body">
          <div class="instrument-visual">
            <img class="instrument-artwork" alt="Instrument artwork" loading="lazy">
            <div class="instrument-ui-surface"></div>
          </div>
          <div class="instrument-controls"></div>
        </div>
        <div class="instrument-keyboard" role="group" aria-label="Instrument keyboard"></div>
        <footer class="instrument-footer">
          <div class="instrument-status small">Load an instrument plugin to begin.</div>
          <label class="instrument-velocity small">Velocity <input class="instrument-velocity-slider" type="range" min="0.2" max="1" step="0.05" value="0.85"></label>
          <button class="btn instrument-preview-note" type="button">🎺 Preview</button>
        </footer>
      </section>
      <section class="rack-log">
        <label style="display:block;margin-bottom:6px;font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.4px;">Rack Activity</label>
        <textarea class="rackOutput" readonly placeholder="Status updates from the plugin rack will appear here."></textarea>
      </section>
    `;

    main.appendChild(blockEl);
    wirePluginRack(blockEl);
    return blockEl;
  }

  function wirePluginRack(blockEl){
    const q = (sel)=> blockEl.querySelector(sel);
    const statusText = q('.status-text');
    const workspacePathLabel = q('.workspacePath');
    const pluginList = q('.pluginLibrary');
    const workspaceNotes = q('.workspaceNotes');
    const copyWorkspaceBtn = q('.copyWorkspace');
    const refreshButtons = blockEl.querySelectorAll('.refreshPlugins');
    const rackOutput = q('.rackOutput');
    const selectedLabel = q('.selectedPlugin');
    const streamsContainer = q('.streamsContainer');
    const rackNotes = q('.rackNotes');
    const hostPanel = q('.host-panel');
    const hostStatusBox = q('.hostStatus');
    const hostParamList = q('.hostParameters');
    const hostWarnings = q('.hostWarnings');
    const hostLoadBtn = q('.hostLoad');
    const hostUnloadBtn = q('.hostUnload');
    const hostPreviewBtn = q('.hostPreview');
    const instrumentPanel = q('.instrument-panel');
    const instrumentTitle = q('.instrument-title');
    const instrumentSubtitle = q('.instrument-subtitle');
    const instrumentArtwork = q('.instrument-artwork');
    const instrumentUISurface = q('.instrument-ui-surface');
    const instrumentControls = q('.instrument-controls');
    const instrumentKeyboard = q('.instrument-keyboard');
    const instrumentStatus = q('.instrument-status');
    const instrumentVelocitySlider = q('.instrument-velocity-slider');
    const instrumentPreviewBtn = q('.instrument-preview-note');
    const instrumentOctaveLabel = q('.instrument-octave-label');
    const instrumentOctDown = q('.instrument-octave-down');
    const instrumentOctUp = q('.instrument-octave-up');

    const instrumentState = {
      descriptor: null,
      currentPath: null,
      octave: 4,
      minOctave: 2,
      maxOctave: 7,
      velocity: 0.85,
      keyDown: new Set(),
      range: { min: 48, max: 72 }
    };

    function log(message){
      if(!rackOutput) return;
      const timestamp = new Date().toLocaleTimeString();
      const next = `[${timestamp}] ${message}`;
      rackOutput.value = next + (rackOutput.value ? '\n' + rackOutput.value : '');
      rackOutput.scrollTop = 0;
    }

    function setSelected(plugin){
      pluginState.selected = plugin || null;
      if(selectedLabel){
        if(plugin){
          const display = plugin.display_name || plugin.name || 'Unknown plugin';
          const details = [];
          if(plugin.format) details.push(plugin.format);
          if(plugin.origin) details.push(plugin.origin);
          selectedLabel.textContent = `Selected: ${display}${details.length ? ' · ' + details.join(' · ') : ''}`;
        }else{
          selectedLabel.textContent = 'Select a plugin to assign it to a lane.';
        }
      }
      if(!pluginList) return;
      Array.from(pluginList.children).forEach((li)=>{
        if(!(li instanceof HTMLElement)) return;
        li.classList.toggle('selected', !!plugin && li.dataset.path === (plugin.path || ''));
      });
      renderHost();
    }

    function renderWorkspaceNotes(status){
      if(!workspaceNotes) return;
      workspaceNotes.innerHTML = '';
      (status.notes || []).forEach((note)=>{
        const span = document.createElement('span');
        span.textContent = note;
        workspaceNotes.appendChild(span);
      });
    }

    const WHITE_NOTES = new Set([0,2,4,5,7,9,11]);
    const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

    function ensureInstrumentRange(descriptor){
      const keyboard = descriptor && descriptor.keyboard ? descriptor.keyboard : null;
      const min = keyboard && typeof keyboard.min_note === 'number' ? keyboard.min_note : 48;
      const max = keyboard && typeof keyboard.max_note === 'number' ? keyboard.max_note : 72;
      instrumentState.range = { min, max };
      instrumentState.minOctave = Math.max(0, Math.floor(min / 12));
      instrumentState.maxOctave = Math.max(instrumentState.minOctave + 1, Math.floor(max / 12));
      instrumentState.octave = clamp(instrumentState.octave, instrumentState.minOctave, instrumentState.maxOctave - 1);
    }

    function updateInstrumentOctaveLabel(){
      if(instrumentOctaveLabel){
        instrumentOctaveLabel.textContent = `Octave ${instrumentState.octave}`;
      }
      if(instrumentOctDown){
        instrumentOctDown.disabled = instrumentState.octave <= instrumentState.minOctave;
      }
      if(instrumentOctUp){
        instrumentOctUp.disabled = instrumentState.octave >= instrumentState.maxOctave - 1;
      }
    }

    function buildInstrumentKeyboard(){
      if(!instrumentKeyboard) return;
      instrumentKeyboard.innerHTML = '';
      const startNote = Math.max(instrumentState.range.min, instrumentState.octave * 12);
      const endNote = Math.min(instrumentState.range.max, startNote + 23);
      for(let note = startNote; note <= endNote; note++){
        const key = document.createElement('button');
        key.type = 'button';
        key.dataset.note = String(note);
        const name = NOTE_NAMES[note % 12];
        key.textContent = name;
        key.className = `instrument-key ${WHITE_NOTES.has(note % 12) ? 'white' : 'black'}`;
        key.addEventListener('pointerdown', (event)=>{
          event.preventDefault();
          handleInstrumentKeyDown(note, key);
        });
        key.addEventListener('pointerup', ()=> handleInstrumentKeyUp(note, key));
        key.addEventListener('pointerleave', ()=> handleInstrumentKeyUp(note, key));
      instrumentKeyboard.appendChild(key);
      }
    }

    function middleInstrumentNote(){
      const min = instrumentState.range.min;
      const max = instrumentState.range.max;
      const mid = Math.round((min + max) / 2);
      return clamp(mid, min, max);
    }

    function handleInstrumentKeyDown(note, element){
      if(!instrumentState.descriptor) return;
      instrumentState.keyDown.add(note);
      if(element) element.classList.add('active');
      triggerInstrumentPlayback(note, instrumentState.velocity);
    }

    function handleInstrumentKeyUp(note, element){
      instrumentState.keyDown.delete(note);
      if(element) element.classList.remove('active');
    }

    function applyInstrumentTheme(descriptor){
      if(!instrumentPanel) return;
      const theme = descriptor && descriptor.theme ? descriptor.theme : {};
      if(theme.background || theme.accentSecondary){
        const end = theme.accentSecondary || theme.background || '#1f2937';
        instrumentPanel.style.background = `linear-gradient(160deg, ${theme.background || '#0f172a'}, ${end})`;
      }else{
        instrumentPanel.style.removeProperty('background');
      }
      instrumentPanel.style.setProperty('--instrument-accent', theme.accent || '#f97316');
      instrumentPanel.style.setProperty('--instrument-surface', theme.panel || 'rgba(9,12,18,.78)');
      instrumentPanel.style.setProperty('--instrument-border', theme.panelStroke || 'rgba(255,255,255,.08)');
      if(instrumentUISurface){
        instrumentUISurface.style.color = theme.text || '';
      }
      if(instrumentControls){
        instrumentControls.style.color = theme.text || '';
      }
    }

    function renderInstrumentControls(descriptor){
      if(!instrumentControls){
        return;
      }
      instrumentControls.innerHTML = '';
      if(!descriptor || !Array.isArray(descriptor.panels)){
        return;
      }
      const parameterLookup = {};
      const params = (hostState.status && hostState.status.parameters) || [];
      params.forEach((param)=>{
        const key = (param.name || '').replace(/\s+/g, '').toLowerCase();
        parameterLookup[key] = param;
      });
      descriptor.panels.forEach((panel)=>{
        const panelEl = document.createElement('section');
        panelEl.className = 'instrument-control-panel';
        if(panel.title){
          const h = document.createElement('h4');
          h.textContent = panel.title;
          panelEl.appendChild(h);
        }
        const layout = document.createElement('div');
        layout.className = panel.layout === 'row' ? 'instrument-control-row' : 'instrument-control-grid';
        (panel.controls || []).forEach((control)=>{
          const key = ((control.param || control.name || '') + '').replace(/\s+/g, '').toLowerCase();
          const param = parameterLookup[key];
          const wrap = document.createElement('div');
          wrap.className = `instrument-control ${control.type === 'knob' ? 'knob' : 'slider'}`;
          const label = document.createElement('label');
          label.textContent = control.label || (param && (param.display_name || param.name)) || (control.param || 'Parameter');
          wrap.appendChild(label);
          const valueSpan = document.createElement('span');
          valueSpan.className = 'value';
          const value = (param && (param.value ?? param.default)) ?? control.value ?? control.min ?? 0;
          valueSpan.textContent = formatParamDisplay(param || control, value);
          wrap.appendChild(valueSpan);
          const slider = document.createElement('input');
          slider.type = 'range';
          const min = control.min !== undefined ? control.min : (param && param.min !== undefined ? param.min : 0);
          const max = control.max !== undefined ? control.max : (param && param.max !== undefined ? param.max : 1);
          slider.min = min;
          slider.max = max;
          slider.step = control.step !== undefined ? control.step : (param && param.step !== undefined ? param.step : 0.01);
          slider.value = value;
          slider.dataset.paramId = (param && param.id !== undefined) ? param.id : (control.id !== undefined ? control.id : control.param);
          slider.addEventListener('input', (event)=>{
            const val = parseFloat(event.target.value);
            valueSpan.textContent = formatParamDisplay(param || control, val);
          });
          slider.addEventListener('change', (event)=>{
            const val = parseFloat(event.target.value);
            commitHostParameter(slider.dataset.paramId || control.param, val, valueSpan);
          });
          wrap.appendChild(slider);
          layout.appendChild(wrap);
        });
        panelEl.appendChild(layout);
        instrumentControls.appendChild(panelEl);
      });
    }

    function renderInstrumentPanel(){
      if(!instrumentPanel) return;
      const plugin = hostState.status && hostState.status.plugin;
      const descriptor = instrumentState.descriptor;
      const isInstrument = descriptor && descriptor.capabilities && descriptor.capabilities.instrument;
      if(!plugin || !isInstrument){
        instrumentPanel.hidden = true;
        if(instrumentStatus){
          instrumentStatus.textContent = plugin ? 'This plugin does not expose instrument playback.' : 'Load an instrument plugin to begin.';
        }
        return;
      }
      instrumentPanel.hidden = false;
      if(instrumentTitle){
        instrumentTitle.textContent = descriptor.title || (plugin.metadata && plugin.metadata.name) || 'Instrument';
      }
      if(instrumentSubtitle){
        instrumentSubtitle.textContent = descriptor.subtitle || (plugin.metadata && plugin.metadata.vendor) || 'Hosted instrument';
      }
      if(instrumentArtwork){
        const art = descriptor.artwork && descriptor.artwork.data_uri;
        if(art){
          instrumentArtwork.src = art;
          instrumentArtwork.style.display = '';
        }else{
          instrumentArtwork.removeAttribute('src');
          instrumentArtwork.style.display = 'none';
        }
      }
      ensureInstrumentRange(descriptor);
      updateInstrumentOctaveLabel();
      buildInstrumentKeyboard();
      renderInstrumentControls(descriptor);
      applyInstrumentTheme(descriptor);
      if(instrumentStatus){
        instrumentStatus.textContent = 'Tap a key to audition notes instantly.';
      }
      if(instrumentVelocitySlider){
        instrumentVelocitySlider.value = instrumentState.velocity;
      }
    }

    function triggerInstrumentPlayback(note, velocity, duration=1.25){
      fetch('/api/vst/play', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ note, velocity, duration })
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Playback failed');
          if(payload.audio){
            playPreviewAudio(payload.audio);
          }
        })
        .catch((err)=>{
          log('Instrument playback failed: ' + (err && err.message || err));
        });
    }

    function fetchInstrumentDescriptor(path){
      if(!path) return Promise.resolve(null);
      return fetch(`/api/vst/ui?path=${encodeURIComponent(path)}`)
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Descriptor load failed');
          instrumentState.descriptor = payload.descriptor || null;
          instrumentState.currentPath = path;
          renderInstrumentPanel();
        })
        .catch((err)=>{
          log('Instrument descriptor failed: ' + (err && err.message || err));
          instrumentState.descriptor = null;
          instrumentState.currentPath = null;
          renderInstrumentPanel();
        });
    }

    function clearInstrument(){
      instrumentState.descriptor = null;
      instrumentState.currentPath = null;
      instrumentState.keyDown.clear();
      if(instrumentKeyboard) instrumentKeyboard.innerHTML = '';
      if(instrumentStatus) instrumentStatus.textContent = 'Load an instrument plugin to begin.';
      if(instrumentPanel) instrumentPanel.hidden = true;
    }

    function formatParamDisplay(param, value){
      if(param.units && param.units.includes('%')){
        return `${Math.round(value * 100)}${param.units}`;
      }
      if(param.units && param.units.toLowerCase() === 'ms'){
        return `${Math.round(value * 1000)} ms`;
      }
      const min = typeof param.min === 'number' ? param.min : 0;
      const max = typeof param.max === 'number' ? param.max : 1;
      const precision = (max - min) <= 1 ? 2 : 3;
      return `${value.toFixed(precision)}${param.units ? ' ' + param.units : ''}`;
    }

    function renderHost(){
      if(!hostPanel) return;
      const status = hostState.status;
      const available = !!(status && status.available);
      const plugin = status && status.plugin;
      if(hostStatusBox){
        if(!status){
          hostStatusBox.textContent = 'Toolkit status pending…';
        }else if(!available){
          hostStatusBox.textContent = 'Flutter VST toolkit not detected. Install it to enable realtime hosting.';
        }else if(plugin){
          const name = plugin.metadata && plugin.metadata.name ? plugin.metadata.name : 'Plugin';
          const vendor = plugin.metadata && plugin.metadata.vendor ? ` · ${plugin.metadata.vendor}` : '';
          hostStatusBox.textContent = `Hosting ${name}${vendor}.`;
        }else{
          hostStatusBox.textContent = 'Toolkit ready. Load a plugin from the library to begin.';
        }
      }
      if(hostWarnings){
        hostWarnings.innerHTML = '';
        if(status && status.warnings){
          status.warnings.forEach((warning)=>{
            const span = document.createElement('span');
            span.textContent = warning;
            hostWarnings.appendChild(span);
          });
        }
      }
      if(hostParamList){
        hostParamList.innerHTML = '';
        if(plugin && status && Array.isArray(status.parameters) && status.parameters.length){
          status.parameters.forEach((param)=>{
            const li = document.createElement('li');
            const label = document.createElement('label');
            label.className = 'hostParamLabel';
            label.textContent = param.display_name || param.name;
            const valueLabel = document.createElement('span');
            valueLabel.textContent = formatParamDisplay(param, param.value ?? param.default ?? param.min);
            label.appendChild(valueLabel);
            li.appendChild(label);
            const slider = document.createElement('input');
            slider.type = 'range';
            const min = (param.min !== undefined) ? param.min : 0;
            const max = (param.max !== undefined) ? param.max : 1;
            slider.min = min;
            slider.max = max;
            slider.step = param.step || 0.01;
            slider.value = (param.value !== undefined) ? param.value : (param.default ?? min);
            slider.dataset.paramId = param.id;
            slider.addEventListener('input', (event)=>{
              const val = parseFloat(event.target.value);
              valueLabel.textContent = formatParamDisplay(param, val);
            });
            slider.addEventListener('change', (event)=>{
              const val = parseFloat(event.target.value);
              commitHostParameter(param.id, val, valueLabel);
            });
            li.appendChild(slider);
            if(param.description){
              const desc = document.createElement('p');
              desc.className = 'small';
              desc.textContent = param.description;
              li.appendChild(desc);
            }
            hostParamList.appendChild(li);
          });
        }
      }
      if(hostLoadBtn){
        hostLoadBtn.disabled = !available || !pluginState.selected;
      }
      if(hostUnloadBtn){
        hostUnloadBtn.disabled = !available || !plugin;
      }
      if(hostPreviewBtn){
        hostPreviewBtn.disabled = !available || !plugin || hostState.busy;
      }
      renderInstrumentPanel();
    }

    function refreshHostStatus(){
      return fetch('/api/vst/status')
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(payload && payload.status){
            hostState.status = payload.status;
            const pluginPath = payload.status && payload.status.plugin && payload.status.plugin.path;
            if(pluginPath){
              if(instrumentState.currentPath !== pluginPath){
                fetchInstrumentDescriptor(pluginPath);
              }
            }else{
              clearInstrument();
            }
          }
          renderHost();
        })
        .catch((err)=>{
          log('Host status failed: ' + (err && err.message || err));
        });
    }

    function commitHostParameter(identifier, value, valueLabel){
      fetch('/api/vst/parameter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: identifier, value }),
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Update failed');
          hostState.status = payload.status;
          if(valueLabel){
            const paramId = parseInt(identifier, 10);
            const updated = (payload.status && payload.status.parameters || []).find((p)=> parseInt(p.id, 10) === paramId);
            if(updated){
              valueLabel.textContent = formatParamDisplay(updated, updated.value ?? value);
            }
          }
          renderHost();
        })
        .catch((err)=>{
          log('Parameter update failed: ' + (err && err.message || err));
          refreshHostStatus();
        });
    }

    function playPreviewAudio(dataUrl){
      if(!dataUrl) return;
      try{
        if(!ACTX) bootAudio();
        const base64 = dataUrl.split(',')[1] || dataUrl;
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for(let i=0;i<len;i++) bytes[i] = binary.charCodeAt(i);
        ACTX.decodeAudioData(bytes.buffer)
          .then((buffer)=>{
            const source = ACTX.createBufferSource();
            source.buffer = buffer;
            const target = MASTER && MASTER.pre ? MASTER.pre : ACTX.destination;
            source.connect(target);
            source.start();
          })
          .catch((err)=>{
            log('Preview playback failed: ' + (err && err.message || err));
          });
      }catch(err){
        log('Preview decode failed: ' + (err && err.message || err));
      }
    }

    function loadSelectedIntoHost(){
      const plugin = pluginState.selected;
      if(!plugin){
        log('Select a plugin from the library first.');
        return;
      }
      hostState.busy = true;
      renderHost();
      fetch('/api/vst/load', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: plugin.path }),
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Load failed');
          hostState.status = payload.status;
          log(`Hosting ${plugin.name || plugin.path}.`);
          fetchInstrumentDescriptor(plugin.path);
        })
        .catch((err)=>{
          log('Load failed: ' + (err && err.message || err));
        })
        .finally(()=>{
          hostState.busy = false;
          renderHost();
        });
    }

    function unloadHost(){
      hostState.busy = true;
      renderHost();
      fetch('/api/vst/unload', { method: 'POST' })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Unload failed');
          hostState.status = payload.status;
          log('Host cleared.');
          clearInstrument();
        })
        .catch((err)=>{
          log('Unload failed: ' + (err && err.message || err));
        })
        .finally(()=>{
          hostState.busy = false;
          renderHost();
        });
    }

    function previewHost(){
      if(!hostState.status || !hostState.status.plugin){
        log('Load a plugin into the host first.');
        return;
      }
      hostState.busy = true;
      renderHost();
      fetch('/api/vst/render', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ duration: 2.0 }),
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Render failed');
          playPreviewAudio(payload.audio);
          log('Rendered preview for hosted plugin.');
        })
        .catch((err)=>{
          log('Preview failed: ' + (err && err.message || err));
        })
        .finally(()=>{
          hostState.busy = false;
          renderHost();
        });
    }

    function renderPluginLibrary(status){
      if(!pluginList) return;
      pluginList.innerHTML = '';
      const plugins = status.plugins || [];
      if(!plugins.length){
        const li = document.createElement('li');
        li.className = 'empty';
        li.textContent = 'Drop plugins into the workspace to begin building a rack.';
        pluginList.appendChild(li);
        setSelected(null);
        return;
      }
      plugins.forEach((plugin)=>{
        const li = document.createElement('li');
        li.dataset.path = plugin.path || '';
        const displayName = plugin.display_name || plugin.name || 'Unknown plugin';
        const title = document.createElement('strong');
        title.textContent = displayName;
        li.appendChild(title);
        const pathSpan = document.createElement('span');
        pathSpan.className = 'path';
        pathSpan.textContent = plugin.relative_path || plugin.path;
        li.appendChild(pathSpan);
        const meta = document.createElement('div');
        meta.className = 'meta small';
        const parts = [];
        if(plugin.format) parts.push(plugin.format);
        if(plugin.size){
          const sizeKb = (plugin.size / 1024).toFixed(1);
          parts.push(`${sizeKb} KB`);
        }
        if(plugin.origin) parts.push(plugin.origin);
        meta.textContent = parts.join(' · ');
        li.appendChild(meta);
        if(plugin.notes && plugin.notes.length){
          li.title = plugin.notes.join('\n');
        }
        li.addEventListener('click', ()=>{
          setSelected(plugin);
          log(`Selected ${displayName}`);
        });
        pluginList.appendChild(li);
        if(pluginState.selected && pluginState.selected.path === plugin.path){
          setSelected(plugin);
        }
      });
    }

    function removePlugin(stream, lane, slot){
      return fetch('/api/plugins/remove', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ stream, lane, slot }),
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Remove failed');
          pluginState.status = payload.status;
          renderPluginLibrary(payload.status);
          renderStreams(payload.status);
          log(`Removed slot ${slot + 1} from ${stream} lane ${lane}.`);
        })
        .catch((err)=>{
          log('Remove failed: ' + (err && err.message || err));
        });
    }

    function assignSelected(stream, lane){
      const plugin = pluginState.selected;
      if(!plugin){
        log('Select a plugin from the library first.');
        return Promise.resolve();
      }
      return fetch('/api/plugins/assign', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ stream, lane, path: plugin.path }),
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Assign failed');
          pluginState.status = payload.status;
          renderPluginLibrary(payload.status);
          renderStreams(payload.status);
          log(`Assigned ${plugin.name} to ${stream} lane ${lane}.`);
        })
        .catch((err)=>{
          log('Assign failed: ' + (err && err.message || err));
        });
    }

    function toggleLane(stream){
      return fetch('/api/plugins/toggle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ stream }),
      })
        .then((res)=>{
          if(!res.ok) throw new Error('status ' + res.status);
          return res.json();
        })
        .then((payload)=>{
          if(!payload.ok) throw new Error(payload.error || 'Toggle failed');
          pluginState.status = payload.status;
          renderPluginLibrary(payload.status);
          renderStreams(payload.status);
          const active = payload.toggle && payload.toggle.active_lane;
          log(`Switched ${stream} to lane ${active}.`);
        })
        .catch((err)=>{
          log('Toggle failed: ' + (err && err.message || err));
        });
    }

    function renderStreams(status){
      if(!streamsContainer) return;
      streamsContainer.innerHTML = '';
      const plugins = status.plugins || [];
      const pluginLookup = new Map(plugins.map((p)=> [p.path, p]));
      const streams = status.streams || {};
      const names = Object.keys(streams);
      if(!names.length){
        const empty = ce('div', 'emptyStreams small');
        empty.textContent = 'Assign a plugin to create your first stream lane.';
        streamsContainer.appendChild(empty);
        return;
      }
      names.sort();
      names.forEach((streamName)=>{
        const streamData = streams[streamName] || {};
        const activeLane = (streamData.active_lane || 'A').toUpperCase();
        const card = ce('section', 'rackStream');
        const head = ce('header', 'rackHead');
        const title = ce('h4');
        title.textContent = streamName;
        head.appendChild(title);
        const statusBadge = ce('span', 'laneStatus small');
        statusBadge.textContent = `Active lane: ${activeLane}`;
        head.appendChild(statusBadge);
        const buttons = ce('div', 'rackButtons');
        const toggleButton = ce('button', 'btn toggleLane');
        toggleButton.textContent = '⇆ Toggle Lane';
        toggleButton.addEventListener('click', (event)=>{
          event.preventDefault();
          toggleLane(streamName);
        });
        buttons.appendChild(toggleButton);
        head.appendChild(buttons);
        card.appendChild(head);

        const lanesWrap = ce('div', 'laneWrap');
        LANE_KEYS.forEach((laneKey)=>{
          const laneData = ((streamData.lanes || {})[laneKey]) || [];
          const laneEl = ce('div', 'laneCard');
          laneEl.dataset.lane = laneKey;
          const laneHeader = ce('header', 'laneHeader');
          const laneTitle = ce('h5');
          laneTitle.textContent = `Lane ${laneKey}`;
          laneHeader.appendChild(laneTitle);
          if(activeLane === laneKey){
            const badge = ce('span', 'laneBadge');
            badge.textContent = 'Live';
            laneHeader.appendChild(badge);
          }
          laneEl.appendChild(laneHeader);

          const list = ce('ul', 'slotList');
          if(!laneData.length){
            const empty = ce('li', 'empty');
            empty.textContent = 'No plugins assigned.';
            list.appendChild(empty);
          }else{
            laneData.forEach((assignment)=>{
              const li = ce('li', 'slot');
              const slotIndex = typeof assignment.slot === 'number'
                ? assignment.slot
                : parseInt(assignment.slot || '0', 10);
              const pluginInfo = assignment.plugin || pluginLookup.get(assignment.path);
              const titleRow = ce('div', 'slotTitle');
              const slotLabel = ce('strong');
              slotLabel.textContent = `Slot ${slotIndex + 1}`;
              titleRow.appendChild(slotLabel);
              const label = document.createTextNode(' ' + (pluginInfo ? (pluginInfo.display_name || pluginInfo.name) : assignment.path));
              titleRow.appendChild(label);
              li.appendChild(titleRow);
              const metaRow = ce('div', 'slotMeta small');
              const details = [];
              if(pluginInfo && pluginInfo.format) details.push(pluginInfo.format);
              if(pluginInfo && pluginInfo.origin) details.push(pluginInfo.origin);
              const rel = pluginInfo && pluginInfo.relative_path ? pluginInfo.relative_path : assignment.path;
              if(rel) details.push(rel);
              metaRow.textContent = details.join(' · ');
              li.appendChild(metaRow);
              const actions = ce('div', 'actions');
              const removeBtn = ce('button', 'btn btn-xs removePlugin');
              removeBtn.textContent = '✖ Remove';
              removeBtn.addEventListener('click', (event)=>{
                event.preventDefault();
                removePlugin(streamName, laneKey, slotIndex);
              });
              actions.appendChild(removeBtn);
              li.appendChild(actions);
              list.appendChild(li);
            });
          }
          laneEl.appendChild(list);
          const controls = ce('div', 'laneControls');
          const assignBtn = ce('button', 'btn btn-xs assignBtn');
          assignBtn.textContent = '＋ Assign selected';
          assignBtn.addEventListener('click', (event)=>{
            event.preventDefault();
            assignSelected(streamName, laneKey);
          });
          controls.appendChild(assignBtn);
          laneEl.appendChild(controls);
          lanesWrap.appendChild(laneEl);
        });
        card.appendChild(lanesWrap);
        streamsContainer.appendChild(card);
      });
    }

    async function refreshRack(logRefresh = false){
      if(statusText) statusText.textContent = 'Refreshing…';
      blockEl.classList.remove('server-offline');
      try{
        const res = await fetch('/api/plugins');
        if(!res.ok) throw new Error('status ' + res.status);
        const data = await res.json();
        pluginState.status = data;
        const count = (data.plugins || []).length;
        if(statusText){
          statusText.textContent = count ? `${count} plugin${count === 1 ? '' : 's'} available` : 'No plugins found';
        }
        if(workspacePathLabel){
          workspacePathLabel.textContent = data.workspace || 'Unavailable';
        }
        renderWorkspaceNotes(data);
        renderPluginLibrary(data);
        renderStreams(data);
        refreshHostStatus();
        if(rackNotes){
          rackNotes.textContent = count
            ? 'Select a plugin and choose a lane to start routing.'
            : 'Drop plugins into the library to start building a rack.';
        }
        if(logRefresh) log('Rack refreshed.');
      }catch(err){
        if(statusText) statusText.textContent = 'Rack offline';
        if(workspacePathLabel) workspacePathLabel.textContent = 'Unavailable';
        blockEl.classList.add('server-offline');
        if(logRefresh) log('Refresh failed: ' + (err && err.message || err));
      }
    }

    refreshButtons.forEach((btn)=>{
      btn.addEventListener('click', (event)=>{
        event.preventDefault();
        refreshRack(true);
      });
    });

    if(hostLoadBtn){
      hostLoadBtn.addEventListener('click', (event)=>{
        event.preventDefault();
        loadSelectedIntoHost();
      });
    }
    if(hostUnloadBtn){
      hostUnloadBtn.addEventListener('click', (event)=>{
        event.preventDefault();
        unloadHost();
      });
    }
    if(hostPreviewBtn){
      hostPreviewBtn.addEventListener('click', (event)=>{
        event.preventDefault();
        previewHost();
      });
    }
    if(instrumentOctDown){
      instrumentOctDown.addEventListener('click', (event)=>{
        event.preventDefault();
        instrumentState.octave = clamp(instrumentState.octave - 1, instrumentState.minOctave, instrumentState.maxOctave - 1);
        updateInstrumentOctaveLabel();
        buildInstrumentKeyboard();
      });
    }
    if(instrumentOctUp){
      instrumentOctUp.addEventListener('click', (event)=>{
        event.preventDefault();
        instrumentState.octave = clamp(instrumentState.octave + 1, instrumentState.minOctave, instrumentState.maxOctave - 1);
        updateInstrumentOctaveLabel();
        buildInstrumentKeyboard();
      });
    }
    if(instrumentVelocitySlider){
      instrumentVelocitySlider.addEventListener('input', (event)=>{
        const val = parseFloat(event.target.value);
        instrumentState.velocity = clamp(val, 0.2, 1.0);
      });
    }
    if(instrumentPreviewBtn){
      instrumentPreviewBtn.addEventListener('click', (event)=>{
        event.preventDefault();
        const note = middleInstrumentNote();
        triggerInstrumentPlayback(note, instrumentState.velocity);
      });
    }

    if(copyWorkspaceBtn){
      copyWorkspaceBtn.addEventListener('click', async ()=>{
        const text = workspacePathLabel ? (workspacePathLabel.textContent || '').trim() : '';
        if(!text || text === 'Not available' || text === 'Unavailable'){
          log('Workspace path unavailable.');
          return;
        }
        if(!navigator.clipboard || !navigator.clipboard.writeText){
          log('Clipboard access is not available in this browser.');
          return;
        }
        const original = copyWorkspaceBtn.textContent;
        try{
          await navigator.clipboard.writeText(text);
          copyWorkspaceBtn.textContent = 'Copied!';
          setTimeout(()=>{ copyWorkspaceBtn.textContent = original; }, 1500);
          log('Workspace path copied to clipboard.');
        }catch(err){
          copyWorkspaceBtn.textContent = 'Copy failed';
          setTimeout(()=>{ copyWorkspaceBtn.textContent = original; }, 2000);
          log('Copy failed: ' + (err && err.message || err));
        }
      });
    }

    const dragHandle = blockEl.querySelector('.dragHandle');
    let drag = null;
    dragHandle.addEventListener('mousedown', (e)=>{
      if(!editMode) return;
      const r = blockEl.getBoundingClientRect();
      const parentR = main.getBoundingClientRect();
      drag = {dx:e.clientX - r.left, dy:e.clientY - r.top, parentR, w:r.width};
      blockEl.classList.add('dragging');
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
      if(!drag) return;
      let x = e.clientX - drag.parentR.left - drag.dx + main.scrollLeft;
      let y = e.clientY - drag.parentR.top - drag.dy + main.scrollTop;
      x = Math.round(x / GRID) * GRID;
      y = Math.round(y / GRID) * GRID;
      blockEl.style.left = x + 'px';
      blockEl.style.top = y + 'px';
      blockEl.style.position = 'absolute';
      blockEl.style.width = Math.max(520, Math.floor(drag.w)) + 'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(!drag) return;
      drag=null;
      blockEl.classList.remove('dragging');
    });

    refreshHostStatus();
    refreshRack();
  }

  function addBlock(){
    if(!ACTX){ bootAudio(); /* resume only on Start Audio click */ }
    const blockEl = ce('div','block');
    const id = ++blockCount;
    blockEl.dataset.id = id;
    blockEl.innerHTML = `
      <h2><span class="dragHandle" style="cursor:move">⣿</span> Block ${id}</h2>
      <div class="row">
        <label>Block Vol</label><input type="range" class="blockVol" min="0" max="1" step="0.001" value="1.0"><span class="small bVolVal">100%</span>
        <button class="btn addStream">Add Stream</button>
        <canvas class="scope" aria-label="Oscilloscope for Block ${id}"></canvas>
      </div>
      <div class="streams"></div>
    `;
    
    // Add reset buttons to block-level sliders (excluding volume)
    ;(function addBlockSliderResets(){
      const ranges = blockEl.querySelectorAll('input[type="range"]');
      ranges.forEach(r=>{
        if(r.classList.contains('no-reset') || r.classList.contains('vol') || /vol/i.test(r.className) || /vol/i.test(r.id||'')) return;
        if(r.nextElementSibling && r.nextElementSibling.classList && r.nextElementSibling.classList.contains('reset')) return;
        const btn = document.createElement('button');
        btn.className = 'btn btn-xs reset';
        btn.textContent = '↺';
        btn.title = 'Reset to default';
        btn.style.marginLeft = '4px';
        r.setAttribute('data-default', r.defaultValue);
        r.insertAdjacentElement('afterend', btn);
        btn.addEventListener('click', ()=>{
          const def = r.getAttribute('data-default');
          if(def!=null){ r.value = def; r.dispatchEvent(new Event('input', {bubbles:true})); }
        });
      });
    })();
const bus = ACTX.createGain(); bus.gain.value = 1.0; bus.connect(MASTER.pre);
    // Per-block analyser for oscilloscope
    const analyser = ACTX.createAnalyser(); analyser.fftSize = 1024;
    bus.connect(analyser);

    const bVol = qs('.blockVol', blockEl);
    const bVolVal = qs('.bVolVal', blockEl);
    bVol.addEventListener('input', ()=>{
      bus.gain.setTargetAtTime(parseFloat(bVol.value)||0, ACTX.currentTime, 0.02);
      bVolVal.textContent = Math.round(parseFloat(bVol.value)*100) + '%';
    });

    qs('.addStream', blockEl).addEventListener('click', ()=>{
      const sIdx = qs('.streams', blockEl).children.length + 1;
      const s = createStream(sIdx, bus);
      qs('.streams', blockEl).appendChild(s.el);
    });

    // Init canvas size for block scope
    const cvs = qs('.scope', blockEl);
    const ctx = cvs.getContext('2d', { willReadFrequently: true });
    const resizeScope = ()=>{ const bb = cvs.getBoundingClientRect(); cvs.width = Math.max(220, Math.floor(bb.width)); cvs.height = 60; };
    resizeScope(); window.addEventListener('resize', resizeScope);

    const blockModel = { el:blockEl, bus, analyser, cvs, ctx, streams:[] };
    blocks.push(blockModel);

    // Drag (Edit mode)
    const handle = blockEl.querySelector('.dragHandle');
    let drag = null;
    
    handle.addEventListener('mousedown', (e)=>{
      if(!editMode) return;
      const r = blockEl.getBoundingClientRect();
      const parentR = main.getBoundingClientRect();
      drag = {dx:e.clientX - r.left, dy:e.clientY - r.top, parentR, w:r.width, h:r.height};
      blockEl.classList.add('dragging');
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
      if(!drag) return;
      let x = e.clientX - drag.parentR.left - drag.dx + main.scrollLeft;
      let y = e.clientY - drag.parentR.top - drag.dy + main.scrollTop;
      // grid snap
      x = Math.round(x / GRID) * GRID;
      y = Math.round(y / GRID) * GRID;
      blockEl.style.left = x + 'px';
      blockEl.style.top = y + 'px';
      blockEl.style.position = 'absolute';
      // fixed width based on initial down
      blockEl.style.width = Math.max(520, Math.floor(drag.w)) + 'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(!drag) return;
      drag=null;
      blockEl.classList.remove('dragging');
    });
main.appendChild(blockEl);

return blockModel;
  }

  function createStream(idx, blockBus){
    const el = ce('div','stream');
    el.innerHTML = `
      
      <h3>Stream ${idx}</h3>
      <div class="row aRow">
        <label>A</label><input class="fileA" type="file" accept="audio/*"><span class="small aName">none</span>
        <div class="spacer"></div>
        <div class="small">A&nbsp;Pos</div>
        <input class="scrubA" type="range" min="0" max="1" step="0.001" value="0" style="width:220px">
        <span class="small curTimeA">0:00</span>
      </div>
      <div class="row bRow">
        <label>B</label><input class="fileB" type="file" accept="audio/*"><span class="small bName">none</span>
        <div class="spacer"></div>
        <div class="small">B&nbsp;Pos</div>
        <input class="scrubB" type="range" min="0" max="1" step="0.001" value="0" style="width:220px">
        <span class="small curTimeB">0:00</span>
      </div>
      <div class="row">
        <button class="btn play">▶ Play</button>
        <button class="btn stop">⏹ Stop</button>
        <label>Loop</label><input type="checkbox" class="loop" checked>
        <div class="spacer"></div>
      



      
      
      </div>
      <div class="row">
        <label>A↔B</label>
        <input class="ab midiable" type="range" min="0" max="1" step="0.001" value="0.5">
        <span class="small abVal">A=B</span>
      </div>
      <div class="row">
        <label>Vol</label>
        <input class="vol midiable" type="range" min="0" max="1" step="0.001" value="1"><span class="small volVal">100%</span>
        <label style="margin-left:10px;">Pan</label>
        <input class="pan midiable" type="range" min="-1" max="1" step="0.001" value="0"><span class="small panVal">C</span>
        <button class="btn mute" title="Mute">Mute</button>
      </div>
<!-- Vertical dropdown modules -->
      <div class="mods">\n
      <div class="mod mod-timepitch">
        <div class="mod-hdr"><span class="name">Time &amp; Pitch</span><span class="carat">▸</span></div>
        <div class="mod-body">
<div class="row">
        <label>Tempo</label>
        <input class="tempo midiable" type="range" min="0.25" max="4" step="0.01" value="1"><span class="small tempoVal">1.00×</span>
        <label style="margin-left:10px;">Pitch</label>
        <input class="pitch midiable" type="range" min="-12" max="12" step="1" value="0"><span class="small pitchVal">0 st</span>
        <label style="margin-left:10px;">Advanced (independent)</label>
        <input class="indepTP" type="checkbox">
      </div>
      <div class="row">
        <label>Reverse A</label><input class="revA" type="checkbox">
        <label style="margin-left:10px;">Reverse B</label><input class="revB" type="checkbox">
      </div>
        </div>
      </div>
    

        <div class="mod muffleMod">
          <div class="mod-hdr"><span class="name">Muffle</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <button class="btn muffle">Muffle: OFF</button>
              <label>Amt</label><input class="mAmt midiable" type="range" min="0" max="1" step="0.001" value="1">
              <span class="small hz">Cutoff: 20,000 Hz</span>
            </div>
          </div>
        </div>

        <div class="mod toneMod">
          <div class="mod-hdr"><span class="name">Tone</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <button class="btn tone">Tone: OFF</button>
              <label>Wave</label>
              <select class="tWave"><option>sine</option><option>square</option><option>triangle</option><option>sawtooth</option></select>
              <label>Preset</label>
              <select class="tPreset">
                <option value="custom">Custom</option>
                <option value="schumann">Schumann (7.83 Hz)</option>
                <option value="delta">Delta (0.5–4)</option>
                <option value="theta">Theta (4–8)</option>
                <option value="alpha">Alpha (8–12)</option>
                <option value="beta">Beta (12–30)</option>
                <option value="gamma">Gamma (30–45)</option>
              </select>
            </div>
            <div class="row">
              <label>Base</label><input class="tBase midiable" type="number" min="20" max="2000" value="200" style="width:70px" title="Carrier base frequency in Hz">
              <label>Δ</label><input class="tBeat midiable" type="number" min="0" max="45" value="10" style="width:60px" title="Binaural beat delta between left and right oscillators (Hz)">
              <label>Level</label><input class="tLevel midiable" type="range" min="0" max="1" step="0.001" value="0.2" style="width:120px" title="Output level of the tone generator">
              <span class="small tSum">L 195.0 Hz / R 205.0 Hz</span>
            </div>
          </div>
        </div>

        <div class="mod noiseMod">
          <div class="mod-hdr"><span class="name">Noise</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <button class="btn noise">Noise: OFF</button>
              <label>Type</label><select class="nType"><option>white</option><option>pink</option><option>brown</option></select>
              <label>Level</label><input class="nLevel midiable" type="range" min="0" max="1" step="0.001" value="0.2" style="width:140px" title="Output level of the noise generator">
              <label>Tilt</label><input class="nTilt midiable" type="range" min="-1" max="1" step="0.01" value="0" style="width:140px" title="Spectral tilt: negative = darker (low boost), positive = brighter (high boost)">
            </div>
          </div>
        </div>

        <div class="mod eqMod">
          <div class="mod-hdr"><span class="name">EQ</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <label class="hasTip" title="Low shelf: boosts/attenuates low frequencies around 120 Hz">Low</label>
              <input class="eqLow midiable" type="range" min="-12" max="12" step="0.1" value="0" style="width:140px"><span class="small eqLowVal">0.0 dB</span>
              <label class="hasTip" title="Mid peaking filter near 1 kHz">Mid</label>
              <input class="eqMid midiable" type="range" min="-12" max="12" step="0.1" value="0" style="width:140px"><span class="small eqMidVal">0.0 dB</span>
              <label class="hasTip" title="High shelf: boosts/attenuates high frequencies above ~8 kHz">High</label>
              <input class="eqHigh midiable" type="range" min="-12" max="12" step="0.1" value="0" style="width:140px"><span class="small eqHighVal">0.0 dB</span>
            </div>
          </div>
        </div>

        <div class="mod fxMod">
          <div class="mod-hdr"><span class="name">FX Chain</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <label class="hasTip" title="Wet/dry balance for the FX return">FX Mix</label>
              <input class="fxMix midiable" type="range" min="0" max="1" step="0.001" value="0" style="width:140px"><span class="small fxMixVal">0%</span>
              <label class="hasTip" title="Delay time in seconds">Delay</label>
              <input class="fxDelay midiable" type="range" min="0" max="1" step="0.001" value="0.25" style="width:140px"><span class="small fxDelayVal">0.25s</span>
              <label class="hasTip" title="Feedback amount (how much of the delay output is fed back)">Feedback</label>
              <input class="fxFb midiable" type="range" min="0" max="0.95" step="0.001" value="0.3" style="width:140px"><span class="small fxFbVal">30%</span>
              <label class="hasTip" title="Waveshaper distortion amount">Dist</label>
              <input class="fxDist midiable" type="range" min="0" max="1" step="0.001" value="0" style="width:140px"><span class="small fxDistVal">0%</span>
            </div>
          </div>
        </div>

        <div class="mod modMatrix">
          <div class="mod-hdr"><span class="name">Modulation</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <button class="btn lfoOn" title="Toggle low-frequency oscillator modulation">LFO: OFF</button>
              <label class="hasTip" title="Which parameter the LFO modulates">Target</label>
              <select class="lfoTarget"><option value="pan">Pan</option><option value="vol">Volume</option><option value="lpf">LPF Cutoff</option><option value="tempo">Tempo</option><option value="pitch">Pitch</option><option value="ab">A↔B Mix</option><option value="apos">A Position</option><option value="bpos">B Position</option></select>
              <label class="hasTip" title="Oscillation speed of LFO">Rate</label>
              <input class="lfoRate midiable" type="range" min="0.05" max="10" step="0.01" value="0.5"><span class="small lfoRateVal">0.50 Hz</span>
              <label class="hasTip" title="Modulation amount of LFO">Depth</label>
              <input class="lfoDepth midiable" type="range" min="0" max="1" step="0.001" value="0.4"><span class="small lfoDepthVal">40%</span>
            </div>
            <div class="row">
              <label class="hasTip" title="Attack: time to rise from 0 to peak">Env A</label>
              <input class="envA midiable" type="range" min="0.001" max="2" step="0.001" value="0.01"><span class="small envAVal">10 ms</span>
              <label class="hasTip" title="Decay: time to drop from peak to sustain level">D</label>
              <input class="envD midiable" type="range" min="0.001" max="2" step="0.001" value="0.2"><span class="small envDVal">0.20 s</span>
              <label class="hasTip" title="Sustain: level held while note is on">S</label>
              <input class="envS midiable" type="range" min="0" max="1" step="0.001" value="0.7"><span class="small envSVal">70%</span>
              <label class="hasTip" title="Release: time to fall back to 0 after stop">R</label>
              <input class="envR midiable" type="range" min="0.001" max="3" step="0.001" value="0.4"><span class="small envRVal">0.40 s</span>
            </div>
          </div>
        </div>

        <div class="mod spaceMod">
          <div class="mod-hdr"><span class="name">Spaces</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <div class="row">
              <label>Preset</label>
              <select class="spPreset">
                <option value="none">None</option>
                <option value="hall">Hall</option>
                <option value="studio">Studio</option>
                <option value="cabin">Cabin</option>
              </select>
              <label>Mix</label><input class="spMix midiable" type="range" min="0" max="1" step="0.001" value="0"><span class="small spMixVal">0%</span>
              <label>Decay</label><input class="spDecay midiable" type="range" min="0.2" max="6" step="0.01" value="1.2"><span class="small spDecayVal">1.20 s</span>
              <label>Pre-Delay</label><input class="spPre midiable" type="range" min="0" max="0.25" step="0.001" value="0.0"><span class="small spPreVal">0.00 s</span>
            </div>
          </div>
        </div>

        <div class="mod spectrumMod">
          <div class="mod-hdr"><span class="name">Spectrogram</span><span class="carat">▸</span></div>
          <div class="mod-body">
            <canvas class="spectro" aria-label="Spectrogram"></canvas>
          </div>
        </div>
      </div>
    
      
      </div><div class="mod-body">
<div class="row">
      <label>Tempo</label>
      <input class="tempo midiable" type="range" min="0.25" max="4" step="0.01" value="1"><span class="small tempoVal">1.00×</span>
      <label style="margin-left:10px;">Pitch</label>
      <input class="pitch midiable" type="range" min="-12" max="12" step="1" value="0"><span class="small pitchVal">0 st</span>
      <label style="margin-left:10px;">Advanced (independent)</label>
      <input class="indepTP" type="checkbox">
    </div>
    <div class="row">
      <label>Reverse A</label><input class="revA" type="checkbox">
      <label style="margin-left:10px;">Reverse B</label><input class="revB" type="checkbox">
    </div>
    </div>
  </div>`;

    
    // Dropdown toggles (supports <div class="mod"><div class="mod-hdr">...</div></div>
    // and <details class="mod"><summary>...</summary> ... </details>)
    el.querySelectorAll('.mod').forEach(mod=>{
      const isDetails = mod.tagName && mod.tagName.toLowerCase()==='details';
      const hdr = mod.querySelector('.mod-hdr') || mod.querySelector('summary');
      let carat = mod.querySelector('.carat');
      if(isDetails){
        // Ensure a carat exists in summary for visual consistency
        if(hdr && !carat){
          carat = document.createElement('span');
          carat.className = 'carat';
          carat.textContent = mod.open ? '▾' : '▸';
          hdr.appendChild(carat);
        }
        mod.classList.toggle('open', !!mod.open);
        mod.addEventListener('toggle', ()=>{
          mod.classList.toggle('open', !!mod.open);
          if(carat) carat.textContent = mod.open ? '▾' : '▸';
        });
      }else if(hdr && carat){
        hdr.addEventListener('click', ()=>{
          const open = !mod.classList.contains('open');
          mod.classList.toggle('open', open);
          carat.textContent = open ? '▾' : '▸';
        });
      }
    });

    // --- Nodes per stream ---

    const gA = ACTX.createGain(); gA.gain.value = 1.0;
    const gB = ACTX.createGain(); gB.gain.value = 1.0; // will set by AB
    const sampleVCA = ACTX.createGain(); sampleVCA.gain.value = 1.0; // ADSR applies here (samples only)
    const genSum = ACTX.createGain(); genSum.gain.value = 1.0; // tone/noise path (always audible)
    const preEQ = ACTX.createGain(); // mix of sampleVCA + generators
    const lpf = ACTX.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=20000; lpf.Q.value=0.707;

    // EQ
    const eqLow = ACTX.createBiquadFilter(); eqLow.type='lowshelf'; eqLow.frequency.value=120; eqLow.gain.value=0;
    const eqMid = ACTX.createBiquadFilter(); eqMid.type='peaking'; eqMid.frequency.value=1000; eqMid.Q.value=1; eqMid.gain.value=0;
    const eqHigh = ACTX.createBiquadFilter(); eqHigh.type='highshelf'; eqHigh.frequency.value=8000; eqHigh.gain.value=0;

    // FX chain (distortion -> delay)
    const dryGain = ACTX.createGain(); dryGain.gain.value = 1.0;
    const fxIn = ACTX.createGain(); const fxOut = ACTX.createGain(); fxOut.gain.value = 0;
    const shaper = ACTX.createWaveShaper();
    const delay = ACTX.createDelay(1.0); delay.delayTime.value = 0.25;
    const fb = ACTX.createGain(); fb.gain.value = 0.3;

    // Spaces (per-stream convolver path)
    const spPre = ACTX.createDelay(1.0); spPre.delayTime.value = 0.0;
    const convolver = ACTX.createConvolver(); convolver.normalize = true;
    const spWet = ACTX.createGain(); spWet.gain.value = 0;

    // Sum -> Pan -> Out
    const sum = ACTX.createGain(); const pan = ACTX.createStereoPanner(); pan.pan.value = 0;
    const out = ACTX.createGain(); out.gain.value = 0.5; // default 50%

    // Routing
    gA.connect(sampleVCA); gB.connect(sampleVCA);
    sampleVCA.connect(preEQ);
    genSum.connect(preEQ);
    preEQ.connect(lpf);
    lpf.connect(eqLow); eqLow.connect(eqMid); eqMid.connect(eqHigh);
    // Split to dry/fx/spaces
    eqHigh.connect(dryGain);
    eqHigh.connect(fxIn);
    eqHigh.connect(spPre);
    // FX path
    fxIn.connect(shaper); shaper.connect(delay); delay.connect(fxOut); delay.connect(fb); fb.connect(delay);
    // Spaces path
    spPre.connect(convolver); convolver.connect(spWet);
    // Sum to pan/out
    dryGain.connect(sum); fxOut.connect(sum); spWet.connect(sum); sum.connect(pan); pan.connect(out); out.connect(blockBus);

    // Visuals: per-block oscilloscope is connected at block bus.
    // Per-stream spectrogram analyser:
    const specAnalyser = ACTX.createAnalyser(); specAnalyser.fftSize = 512; out.connect(specAnalyser);

    // Sampler state
    const sample = { indepTP:false, A:{buf:null,revBuf:null,src:null,name:'',dur:0,offset:0,startTime:0, reverse:false}, B:{buf:null,revBuf:null,src:null,name:'',dur:0,offset:0,startTime:0, reverse:false}, loop:true, playing:false, tempo:1.0, pitch:0 };
    // expose for preset save
    el._streamState = sample;

    // LFO state (JS-driven for general targets)
    const lfo = { enabled:false, rate:0.5, depth:0.4, target:'pan', t0:performance.now(), wave:'sine' };
    const sh = { enabled:false, target:'pan', rate:2, depth:0.25, t0:performance.now(), tPrev:0, val:0 };

    // Envelope (ADSR) applied to sampleVCA only
    const env = { a:0.01, d:0.2, s:0.7, r:0.4 };

    // Helpers
    const decodeFile = (file)=> new Promise((res,rej)=>{
      const fr = new FileReader();
      fr.onload = async ev => {
        try{ const buf = await ACTX.decodeAudioData(ev.target.result); res(buf); }
        catch(err){ rej(err); }
      };
      fr.readAsArrayBuffer(file);
    });

    const startSide = (side, gainNode, when=ACTX.currentTime, offset=0, rate=1)=>{
      if(!side.buf) return null;
      try{ if(side.src){ try{ side.src.stop(); }catch(e){} } }catch(e){}
      const src = ACTX.createBufferSource();
      const useBuf = (side.reverse ? (side.revBuf||side.buf) : side.buf);
    src.buffer = useBuf; src.loop = sample.loop;
      src.playbackRate.value = (rate||1);
    src.connect(gainNode);
      src.start(when, (useBuf && useBuf.duration ? (offset % useBuf.duration) : 0));
      side.src = src;
      return src;
    };

    function trigEnvAttack(){
      const now = ACTX.currentTime;
      sampleVCA.gain.cancelScheduledValues(now);
      sampleVCA.gain.setValueAtTime(0, now);
      const base = 1;
      sampleVCA.gain.linearRampToValueAtTime(base, now + env.a);
      sampleVCA.gain.linearRampToValueAtTime(base * env.s, now + env.a + env.d);
    }
    function trigEnvRelease(){
      const now = ACTX.currentTime;
      const cur = sampleVCA.gain.value;
      sampleVCA.gain.cancelScheduledValues(now);
      sampleVCA.gain.setValueAtTime(cur, now);
      sampleVCA.gain.linearRampToValueAtTime(0, now + env.r);
    }

    function startPlayback(){
    const when = ACTX.currentTime + 0.01;
    if(sample.indepTP && sample.A.proc && sample.B.proc){
      // Independent: drive granular processors
      const rate = sample.tempo||1, semi = sample.pitch||0;
      // gate on, set params, seek
      [ ['A', sample.A, gA], ['B', sample.B, gB] ].forEach(([key, side, g])=>{
        const node = side.proc;
        node.parameters.get('rate').value = rate;
        node.parameters.get('transpose').value = semi;
        node.parameters.get('gate').value = 1;
        node.port.postMessage({type:'params', loop: sample.loop, reverse: !!side.reverse});
        const off = side.offset || 0;
        node.port.postMessage({type:'seek', time: off});
      });
      sample.A.startTime = when - (sample.A.offset / rate);
      sample.B.startTime = when - (sample.B.offset / rate);
      sample.playing = true;
      qs('.play', el).classList.add('on');
      try{ trigEnvAttack(); }catch(e){}
    }else{
      // Classic path (tempo & pitch are coupled)
      const rate = (sample.tempo||1) * Math.pow(2, (sample.pitch||0)/12);
      startSide(sample.A, gA, when, sample.A.offset, rate);
      startSide(sample.B, gB, when, sample.B.offset, rate);
      sample.A.startTime = when - (sample.A.offset / rate);
      sample.B.startTime = when - (sample.B.offset / rate);
      sample.playing = true;
      qs('.play', el).classList.add('on');
      try{ trigEnvAttack(); }catch(e){}
    }
  }
    function stopPlayback(){
    try{ if(sample.A.src){ sample.A.src.stop(); sample.A.src.disconnect(); sample.A.src=null; } }catch(e){}
    try{ if(sample.B.src){ sample.B.src.stop(); sample.B.src.disconnect(); sample.B.src=null; } }catch(e){}
    try{ if(sample.indepTP && sample.A.proc){ sample.A.proc.parameters.get('gate').value = 0; } }catch(e){}
    try{ if(sample.indepTP && sample.B.proc){ sample.B.proc.parameters.get('gate').value = 0; } }catch(e){}
    sample.playing = false;
    qs('.play', el).classList.remove('on');
    try{ trigEnvRelease(); }catch(e){}
  }

  // Files
    qs('.fileA', el).addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      try{ sample.A.buf = await decodeFile(f); sample.A.revBuf = makeReversedBuffer(sample.A.buf);
        
        if(sample.A.proc){
          const L = sample.A.buf.getChannelData(0).slice();
          const R = (sample.A.buf.numberOfChannels>1)?sample.A.buf.getChannelData(1).slice():null;
          sample.A.proc.port.postMessage({type:'setBuffer', L, R});
          if(sample.playing){ sample.A.proc.port.postMessage({type:'seek', time: sample.A.offset||0}); }
        }
        if(sample.A.proc){ const L = sample.A.buf.getChannelData(0).slice(); const R = (sample.A.buf.numberOfChannels>1)?sample.A.buf.getChannelData(1).slice():null; sample.A.proc.port.postMessage({type:'setBuffer', L, R}); }
        sample.A.name=f.name; sample.A.dur = sample.A.buf.duration; updateDurations(); qs('.aName', el).textContent = f.name; updateDurations(); if(sample.playing) startPlayback(); }catch{ alert('Failed to load A'); }
    });
    qs('.fileB', el).addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      try{ sample.B.buf = await decodeFile(f); sample.B.revBuf = makeReversedBuffer(sample.B.buf);
        
        if(sample.B.proc){
          const L = sample.B.buf.getChannelData(0).slice();
          const R = (sample.B.buf.numberOfChannels>1)?sample.B.buf.getChannelData(1).slice():null;
          sample.B.proc.port.postMessage({type:'setBuffer', L, R});
          if(sample.playing){ sample.B.proc.port.postMessage({type:'seek', time: sample.B.offset||0}); }
        }
        if(sample.B.proc){ const L = sample.B.buf.getChannelData(0).slice(); const R = (sample.B.buf.numberOfChannels>1)?sample.B.buf.getChannelData(1).slice():null; sample.B.proc.port.postMessage({type:'setBuffer', L, R}); }
        sample.B.name=f.name; sample.B.dur = sample.B.buf.duration; updateDurations(); qs('.bName', el).textContent = f.name; updateDurations(); if(sample.playing) startPlayback(); }catch{ alert('Failed to load B'); }
    });

    
    const fmtTime = s=>{ if(!isFinite(s)) return '0:00'; const m=Math.floor(s/60); const ss=Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; };

    const scrubA = qs('.scrubA', el), curTA = qs('.curTimeA', el), durTA = qs('.durTimeA', el);
    const scrubB = qs('.scrubB', el), curTB = qs('.curTimeB', el), durTB = qs('.durTimeB', el);

    function updateDurations(){
      durTA.textContent = fmtTime(sample.A.dur||0);
      durTB.textContent = fmtTime(sample.B.dur||0);
    }

    function updateScrubA(){
      const dur = sample.A.dur||0;
      if(dur<=0){ curTA.textContent = '0:00'; scrubA.value=0; requestAnimationFrame(updateScrubA); return; }
      const rate = sample.indepTP ? (sample.tempo||1) : ((sample.tempo||1) * Math.pow(2,(sample.pitch||0)/12)); const t = sample.playing && (sample.indepTP || sample.A.src) ? ((ACTX.currentTime - sample.A.startTime) * rate) % dur : (sample.A.offset % dur);
      curTA.textContent = fmtTime(t);
      scrubA.value = (t/dur).toFixed(3);
      requestAnimationFrame(updateScrubA);
    }
    function updateScrubB(){
      const dur = sample.B.dur||0;
      if(dur<=0){ curTB.textContent = '0:00'; scrubB.value=0; requestAnimationFrame(updateScrubB); return; }
      const rate = sample.indepTP ? (sample.tempo||1) : ((sample.tempo||1) * Math.pow(2,(sample.pitch||0)/12)); const t = sample.playing && (sample.indepTP || sample.B.src) ? ((ACTX.currentTime - sample.B.startTime) * rate) % dur : (sample.B.offset % dur);
      curTB.textContent = fmtTime(t);
      scrubB.value = (t/dur).toFixed(3);
      requestAnimationFrame(updateScrubB);
    }
    requestAnimationFrame(updateScrubA);
    requestAnimationFrame(updateScrubB);

    scrubA.addEventListener('input', ()=>{
      const dur = sample.A.dur||0; if(dur<=0) return;
      sample.A.offset = parseFloat(scrubA.value) * dur;
      if(sample.playing) startPlayback();
    });
    scrubB.addEventListener('input', ()=>{
      const dur = sample.B.dur||0; if(dur<=0) return;
      sample.B.offset = parseFloat(scrubB.value) * dur;
      if(sample.playing) startPlayback();
    });

    // Playback controls
    // Add reset buttons for range sliders (except any *vol* sliders)
    (function addSliderResets(){
      const ranges = el.querySelectorAll('input[type="range"]');
      ranges.forEach(r=>{
        if(r.classList.contains('no-reset') || r.classList.contains('vol') || /vol/i.test(r.className) || /vol/i.test(r.id||'')) return;
        if(r.nextElementSibling && r.nextElementSibling.classList && r.nextElementSibling.classList.contains('reset')) return;
        const btn = document.createElement('button');
        btn.className = 'btn btn-xs reset';
        btn.textContent = '↺';
        btn.title = 'Reset to default';
        btn.style.marginLeft = '4px';
        r.setAttribute('data-default', r.defaultValue);
        r.insertAdjacentElement('afterend', btn);
        btn.addEventListener('click', ()=>{
          const def = r.getAttribute('data-default');
          if(def!=null){ r.value = def; r.dispatchEvent(new Event('input', {bubbles:true})); }
        });
      });
    })();

    qs('.play', el).addEventListener('click', ()=>{ if(!sample.playing) startPlayback(); else stopPlayback(); });
    qs('.stop', el).addEventListener('click', ()=> stopPlayback());
    qs('.loop', el).addEventListener('change', (e)=>{ sample.loop = e.target.checked; if(sample.playing) startPlayback(); });

    
    // Time & Pitch controls (listeners + init)
    const tempo = qs('.tempo', el), tempoVal = qs('.tempoVal', el);
    const pitch = qs('.pitch', el), pitchVal = qs('.pitchVal', el);
    const indep = qs('.indepTP', el);
    const revA = qs('.revA', el), revB = qs('.revB', el);

    function _updateTPReadouts(){
      if(tempo && tempoVal){ tempoVal.textContent = (parseFloat(tempo.value)||1).toFixed(2)+'×'; }
      if(pitch && pitchVal){ pitchVal.textContent = (parseInt(pitch.value,10)||0) + ' st'; }
    }

    if(tempo){ tempo.addEventListener('input', ()=>{
      sample.tempo = parseFloat(tempo.value)||1;
      _updateTPReadouts();
      if(sample.indepTP){
        try{ if(sample.A.proc) sample.A.proc.parameters.get('rate').value = sample.tempo; if(sample.B.proc) sample.B.proc.parameters.get('rate').value = sample.tempo; }catch(e){}
      }else if(sample.playing){ startPlayback(); }
    }); }
    if(pitch){ pitch.addEventListener('input', ()=>{
      sample.pitch = parseInt(pitch.value,10)||0;
      _updateTPReadouts();
      if(sample.indepTP){
        try{ if(sample.A.proc) sample.A.proc.parameters.get('transpose').value = sample.pitch; if(sample.B.proc) sample.B.proc.parameters.get('transpose').value = sample.pitch; }catch(e){}
      }else if(sample.playing){ startPlayback(); }
    }); }
    if(revA){ revA.addEventListener('change', ()=>{
      sample.A.reverse = !!revA.checked;
      if(sample.indepTP && sample.A.proc){ try{ sample.A.proc.port.postMessage({type:'params', reverse: sample.A.reverse}); }catch(e){} }
      else if(sample.playing){ startPlayback(); }
    }); }
    if(revB){ revB.addEventListener('change', ()=>{
      sample.B.reverse = !!revB.checked;
      if(sample.indepTP && sample.B.proc){ try{ sample.B.proc.port.postMessage({type:'params', reverse: sample.B.reverse}); }catch(e){} }
      else if(sample.playing){ startPlayback(); }
    }); }
    if(indep){ indep.addEventListener('change', ()=>{
      sample.indepTP = !!indep.checked;
      applyIndepRouting(sample, gA, gB);
      if(sample.indepTP){
        try{
          if(sample.A.proc){ sample.A.proc.parameters.get('rate').value = sample.tempo||1; sample.A.proc.parameters.get('transpose').value = sample.pitch||0; sample.A.proc.port.postMessage({type:'params', loop: sample.loop, reverse: !!sample.A.reverse}); }
          if(sample.B.proc){ sample.B.proc.parameters.get('rate').value = sample.tempo||1; sample.B.proc.parameters.get('transpose').value = sample.pitch||0; sample.B.proc.port.postMessage({type:'params', loop: sample.loop, reverse: !!sample.B.reverse}); }
        }catch(e){}
      }
      if(sample.playing) startPlayback();
    }); }

    // Initialize values + routing
    if(tempo){ sample.tempo = parseFloat(tempo.value)||1; }
    if(pitch){ sample.pitch = parseInt(pitch.value,10)||0; }
    if(revA){ sample.A.reverse = !!revA.checked; }
    if(revB){ sample.B.reverse = !!revB.checked; }
    if(indep){ sample.indepTP = !!indep.checked; applyIndepRouting(sample, gA, gB); }
    _updateTPReadouts();
// AB mix
    const ab = qs('.ab', el), abVal = qs('.abVal', el);
    if(ab && abVal){ ab.addEventListener('input', ()=>{
      const mix = parseFloat(ab.value)||0.5;
      gA.gain.setTargetAtTime(1 - mix, ACTX.currentTime, 0.02);
      gB.gain.setTargetAtTime(mix, ACTX.currentTime, 0.02);
      abVal.textContent = mix<0.01?'A':(mix>0.99?'B':(Math.abs(mix-0.5)<0.01?'A=B':mix.toFixed(2)));
    });
    ab.dispatchEvent(new Event('input')); }

    // Volume / Pan / Mute
    const vol = qs('.vol', el), volVal = qs('.volVal', el);
    const mute = qs('.mute', el), panEl = qs('.pan', el), panVal = qs('.panVal', el);
    if(vol && volVal){
      vol.addEventListener('input', ()=>{
        const v = parseFloat(vol.value)||0;
        sum.gain.setTargetAtTime(v, ACTX.currentTime, 0.02);
        volVal.textContent = Math.round(v*100)+'%';
      });
    }
    if(panEl && panVal){
      panEl.addEventListener('input', ()=>{
        const v = parseFloat(panEl.value)||0;
        pan.pan.setTargetAtTime(v, ACTX.currentTime, 0.02);
        panVal.textContent = fmtPan(v);
      });
    }
    let isMuted = false;
    if(mute){
      mute.addEventListener('click', ()=>{
        isMuted = !isMuted;
        out.gain.setTargetAtTime(isMuted?0:1, ACTX.currentTime, 0.02);
        mute.classList.toggle('on', isMuted);
      });
    }

    // Muffle (LPF)
    const mBtn = qs('.mBtn', el), mAmt = qs('.mAmt', el), hz = qs('.hz', el);
    let mOn = false;
    const applyMuffle = ()=>{
      if(!mAmt) return;
      const f = valueToFreq(parseFloat(mAmt.value)||1);
      if(hz) hz.textContent = 'Cutoff: ' + Math.round(f).toLocaleString() + ' Hz';
      if(mOn){ lpf.frequency.setTargetAtTime(f, ACTX.currentTime, 0.02); }
      else { lpf.frequency.setTargetAtTime(20000, ACTX.currentTime, 0.02); }
      if(mBtn) mBtn.textContent = 'Muffle: ' + (mOn?'ON':'OFF');
    };
    if(mBtn){ mBtn.addEventListener('click', ()=>{ mOn=!mOn; applyMuffle(); }); }
    if(mAmt){ mAmt.addEventListener('input', applyMuffle); applyMuffle(); }

    // Tone (binaural)
    // Tone (binaural)
    const tBtn = qs('.tone', el), tWave = qs('.tWave', el), tPreset = qs('.tPreset', el),
          tBase = qs('.tBase', el), tBeat = qs('.tBeat', el), tLevel = qs('.tLevel', el), tSum = qs('.tSum', el);
    const tone = { enabled:false, nodes:null, wave:'sine', base:200, beat:10, level:0.2 };
    function ensureTone(){
      if(tone.nodes) return;
      const lPan = ACTX.createStereoPanner(); lPan.pan.value = -1;
      const rPan = ACTX.createStereoPanner(); rPan.pan.value = 1;
      const lGain = ACTX.createGain(); const rGain = ACTX.createGain();
      lGain.gain.value = rGain.gain.value = tone.level;
      lPan.connect(lGain); rPan.connect(rGain);
      // Connect tone into generators sum (so it's always audible even if samples stop)
      lGain.connect(genSum); rGain.connect(genSum);
      tone.nodes = { lPan, rPan, lGain, rGain, lOsc:null, rOsc:null };
    }
    function stopTone(){ if(!tone.nodes) return; try{ if(tone.nodes.lOsc){ try{ tone.nodes.lOsc.stop(); }catch(e){} }; if(tone.nodes.rOsc){ try{ tone.nodes.rOsc.stop(); }catch(e){} }; }catch(e){} tone.nodes.lOsc=tone.nodes.rOsc=null; }
    function startTone(){ ensureTone(); stopTone(); const n=tone.nodes;
      n.lOsc = ACTX.createOscillator(); n.rOsc = ACTX.createOscillator();
      n.lOsc.type = n.rOsc.type = tone.wave;
      n.lOsc.frequency.value = tone.base - tone.beat/2;
      n.rOsc.frequency.value = tone.base + tone.beat/2;
      n.lOsc.connect(n.lPan); n.rOsc.connect(n.rPan);
      n.lOsc.start(); n.rOsc.start();
      updateToneSummary();
    }
    function applyTone(){ if(!tone.nodes) return; tone.nodes.lGain.gain.setTargetAtTime(tone.level, ACTX.currentTime, 0.02); tone.nodes.rGain.gain.setTargetAtTime(tone.level, ACTX.currentTime, 0.02);
      if(tone.nodes.lOsc) tone.nodes.lOsc.frequency.setTargetAtTime(tone.base - tone.beat/2, ACTX.currentTime, 0.02);
      if(tone.nodes.rOsc) tone.nodes.rOsc.frequency.setTargetAtTime(tone.base + tone.beat/2, ACTX.currentTime, 0.02); updateToneSummary(); }
    function updateToneSummary(){ const L = tone.base - tone.beat/2, R = tone.base + tone.beat/2; tSum.textContent = 'L ' + L.toFixed(1) + ' Hz / R ' + R.toFixed(1) + ' Hz'; }
    tBtn.addEventListener('click', ()=>{ tone.enabled=!tone.enabled; tBtn.textContent = 'Tone: ' + (tone.enabled?'ON':'OFF'); tBtn.classList.toggle('on', tone.enabled); if(tone.enabled){ startTone(); applyTone(); } else { stopTone(); } });
    tWave.addEventListener('change', ()=>{ tone.wave = tWave.value; if(tone.enabled){ startTone(); applyTone(); } });
    tBase.addEventListener('input', ()=>{ tone.base = clamp(parseFloat(tBase.value)||200, 20, 2000); applyTone(); });
    tBeat.addEventListener('input', ()=>{ tone.beat = clamp(parseFloat(tBeat.value)||0, 0, 45); applyTone(); });
    tLevel.addEventListener('input', ()=>{ tone.level = parseFloat(tLevel.value)||0; applyTone(); });
    tPreset.addEventListener('change', ()=>{
      const v = tPreset.value;
      const map = { schumann:7.83, delta:2.0, theta:6.0, alpha:10.0, beta:20.0, gamma:40.0 };
      if(map[v]){ tBeat.value = map[v]; tone.beat = map[v]; applyTone(); }
    });
    updateToneSummary();

    // Noise (with spectral tilt)
    const nBtn = qs('.noise', el), nType = qs('.nType', el), nLevel = qs('.nLevel', el), nTilt = qs('.nTilt', el);
    const noise = { enabled:false, type:'white', level:0.2, src:null, gain:null, tilt:0, loShelf:null, hiShelf:null };
    function buildNoiseBuffer(type){
      const len = ACTX.sampleRate * 2;
      const buf = ACTX.createBuffer(1, len, ACTX.sampleRate);
      const data = buf.getChannelData(0);
      if(type==='white'){
        for(let i=0;i<len;i++) data[i] = Math.random()*2-1;
      }else if(type==='pink'){
        let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
        for(let i=0;i<len;i++){
          const white = Math.random()*2-1;
          b0 = 0.99886*b0 + white*0.0555179;
          b1 = 0.99332*b1 + white*0.0750759;
          b2 = 0.96900*b2 + white*0.1538520;
          b3 = 0.86650*b3 + white*0.3104856;
          b4 = 0.55000*b4 + white*0.5329522;
          b5 = -0.7616*b5 - white*0.0168980;
          data[i] = b0+b1+b2+b3+b4+b5+b6+white*0.5362;
          data[i] *= 0.11;
          b6 = white*0.115926;
        }
      }else{ // brown
        let last=0;
        for(let i=0;i<len;i++){
          const white = Math.random()*2-1;
          last = (last + 0.02 * white) / 1.02;
          data[i] = last * 3.5;
        }
      }
      return buf;
    }
    function startNoise(){
      stopNoise();
      noise.gain = ACTX.createGain(); noise.gain.gain.value = noise.level;
      noise.src = ACTX.createBufferSource(); noise.src.buffer = buildNoiseBuffer(noise.type); noise.src.loop = true;
      // Tilt filters
      noise.loShelf = ACTX.createBiquadFilter(); noise.loShelf.type='lowshelf'; noise.loShelf.frequency.value=300;
      noise.hiShelf = ACTX.createBiquadFilter(); noise.hiShelf.type='highshelf'; noise.hiShelf.frequency.value=4000;
      noise.src.connect(noise.loShelf); noise.loShelf.connect(noise.hiShelf); noise.hiShelf.connect(noise.gain);
      noise.gain.connect(genSum); // into generator path so always audible
      noise.src.start();
    }
    function stopNoise(){ try{ if(noise.src){ try{ noise.src.stop(); }catch(e){} }; }catch(e){} noise.src=null; if(noise.gain){ noise.gain.disconnect(); noise.gain=null; } }
    function applyNoise(){
      if(noise.gain) noise.gain.gain.setTargetAtTime(noise.level, ACTX.currentTime, 0.02);
      const t = parseFloat(nTilt.value)||0;
      if(noise.loShelf && noise.hiShelf){
        noise.loShelf.gain.value = clamp(t<0 ? Math.abs(t)*12 : -t*6, -12, 12); // darken/brighten balance
        noise.hiShelf.gain.value = clamp(t>0 ? t*12 : -Math.abs(t)*6, -12, 12);
      }
    }
    nBtn.addEventListener('click', ()=>{ noise.enabled=!noise.enabled; nBtn.textContent='Noise: '+(noise.enabled?'ON':'OFF'); nBtn.classList.toggle('on', noise.enabled); if(noise.enabled){ startNoise(); applyNoise(); } else { stopNoise(); } });
    nType.addEventListener('change', ()=>{ noise.type = nType.value; if(noise.enabled){ startNoise(); applyNoise(); } });
    nLevel.addEventListener('input', ()=>{ noise.level = parseFloat(nLevel.value)||0; applyNoise(); });
    nTilt.addEventListener('input', applyNoise);

    // EQ binds
    const bEq = (cls,valCls,node)=>{
      const r=qs(cls,el), outLbl=qs(valCls,el);
      r.addEventListener('input', ()=>{ const dB=parseFloat(r.value)||0; node.gain.setTargetAtTime(dB, ACTX.currentTime, 0.02); outLbl.textContent = dB.toFixed(1)+' dB'; });
      r.dispatchEvent(new Event('input'));
    };
    bEq('.eqLow','.eqLowVal',eqLow);
    bEq('.eqMid','.eqMidVal',eqMid);
    bEq('.eqHigh','.eqHighVal',eqHigh);

    // FX binds (with tooltips already)
    const fxMix = qs('.fxMix',el), fxMixVal = qs('.fxMixVal',el);
    const fxDelay = qs('.fxDelay',el), fxDelayVal = qs('.fxDelayVal',el);
    const fxFb = qs('.fxFb',el), fxFbVal = qs('.fxFbVal',el);
    const fxDist = qs('.fxDist',el), fxDistVal = qs('.fxDistVal',el);
    fxMix.addEventListener('input', ()=>{ fxOut.gain.setTargetAtTime(parseFloat(fxMix.value)||0, ACTX.currentTime, 0.02); fxMixVal.textContent = Math.round(parseFloat(fxMix.value)*100)+'%'; });
    fxDelay.addEventListener('input', ()=>{ delay.delayTime.setTargetAtTime(parseFloat(fxDelay.value)||0, ACTX.currentTime, 0.02); fxDelayVal.textContent = (parseFloat(fxDelay.value)||0).toFixed(2)+'s'; });
    fxFb.addEventListener('input', ()=>{ fb.gain.setTargetAtTime(parseFloat(fxFb.value)||0, ACTX.currentTime, 0.02); fxFbVal.textContent = Math.round(parseFloat(fxFb.value)*100)+'%'; });
    fxDist.addEventListener('input', ()=>{ shaper.curve = makeDistCurve(parseFloat(fxDist.value)||0); fxDistVal.textContent = Math.round(parseFloat(fxDist.value)*100)+'%'; });
    function makeDistCurve(amount){ const k = amount*1000+1; const n=44100; const curve=new Float32Array(n); const deg=Math.PI/180; for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=(3+k)*x*20*deg/(Math.PI+k*Math.abs(x)); } return curve; }
    fxMix.dispatchEvent(new Event('input')); fxDelay.dispatchEvent(new Event('input')); fxFb.dispatchEvent(new Event('input')); fxDist.dispatchEvent(new Event('input'));

    // Spaces (per stream)
    function makeImpulse(duration=1.2, decay=2.5){
      const rate = ACTX.sampleRate;
      const len = Math.max(1, Math.floor(rate * duration));
      const impulse = ACTX.createBuffer(2, len, rate);
      for(let ch=0; ch<2; ch++){
        const data = impulse.getChannelData(ch);
        for(let i=0; i<len; i++){
          data[i] = (Math.random()*2-1) * Math.pow(1 - i/len, decay);
        }
      }
      return impulse;
    }
    const spPreset = qs('.spPreset', el), spMix = qs('.spMix', el), spMixVal = qs('.spMixVal', el), spDecay = qs('.spDecay', el), spDecayVal = qs('.spDecayVal', el), spPreEl = qs('.spPre', el), spPreVal = qs('.spPreVal', el);
    function updSpacePreset(){
      let dur=1.2, dec=2.5;
      if(spPreset.value==='hall'){ dur=3.2; dec=3.5; }
      if(spPreset.value==='studio'){ dur=1.4; dec=2.0; }
      if(spPreset.value==='cabin'){ dur=0.9; dec=1.8; }
      convolver.buffer = makeImpulse(parseFloat(spDecay.value)||dur, dec);
    }
    spPreset.addEventListener('change', updSpacePreset);
    spDecay.addEventListener('input', ()=>{ spDecayVal.textContent = (parseFloat(spDecay.value)||1.2).toFixed(2)+' s'; updSpacePreset(); });
    spMix.addEventListener('input', ()=>{ spWet.gain.setTargetAtTime(parseFloat(spMix.value)||0, ACTX.currentTime, 0.02); spMixVal.textContent = Math.round(parseFloat(spMix.value)*100)+'%'; });
    spPreEl.addEventListener('input', ()=>{ spPre.delayTime.setTargetAtTime(parseFloat(spPreEl.value)||0, ACTX.currentTime, 0.02); spPreVal.textContent = (parseFloat(spPreEl.value)||0).toFixed(2)+' s'; });
    updSpacePreset(); spMix.dispatchEvent(new Event('input')); spPreEl.dispatchEvent(new Event('input'));

    // LFO loop
    const lfoOn = qs('.lfoOn', el), lfoTarget = qs('.lfoTarget', el), lfoRate = qs('.lfoRate', el), lfoDepth = qs('.lfoDepth', el);
    lfoOn.addEventListener('click', ()=>{ lfo.enabled=!lfo.enabled; lfoOn.textContent='LFO: '+(lfo.enabled?'ON':'OFF'); lfoOn.classList.toggle('on', lfo.enabled); lfo.t0=performance.now(); });
    lfoTarget.addEventListener('change', ()=>{ lfo.target = lfoTarget.value; });
    lfoRate.addEventListener('input', ()=>{ lfo.rate = parseFloat(lfoRate.value)||0.5; qs('.lfoRateVal', el).textContent = lfo.rate.toFixed(2)+' Hz'; });
    lfoDepth.addEventListener('input', ()=>{ lfo.depth = parseFloat(lfoDepth.value)||0.4; qs('.lfoDepthVal', el).textContent = Math.round(lfo.depth*100)+'%'; });
    lfoRate.dispatchEvent(new Event('input')); lfoDepth.dispatchEvent(new Event('input'));

    function lfoTick(ts){
      if(lfo.enabled){
        const t = (ts - lfo.t0)/1000;
        const phase = Math.sin(2*Math.PI*lfo.rate * t);
        const d = lfo.depth;
        if(lfo.target==='pan'){
          const base = parseFloat(panEl.value)||0;
          pan.pan.setValueAtTime(clamp(base + phase*d, -1, 1), ACTX.currentTime);
        }else if(lfo.target==='vol'){
          const base = parseFloat(vol.value)||0.5;
          out.gain.setValueAtTime(clamp(base * (1 - d/2 + (phase+1)/2*d), 0, 1), ACTX.currentTime);
        }else if(lfo.target==='lpf'){
          const x = clamp((phase+1)/2, 0, 1);
          const f = valueToFreq(x);
          if(mOn){ lpf.frequency.setValueAtTime(f, ACTX.currentTime); } // respect muffle on/off
        }
      }
    }
    LFO_TICKS.push(lfoTick); ensureLfoLoop();
// Envelope binds
    const envA = qs('.envA', el), envD = qs('.envD', el), envS = qs('.envS', el), envR = qs('.envR', el);
    envA.addEventListener('input', ()=>{ env.a = parseFloat(envA.value)||0.01; qs('.envAVal', el).textContent = Math.round(env.a*1000)+' ms'; });
    envD.addEventListener('input', ()=>{ env.d = parseFloat(envD.value)||0.2; qs('.envDVal', el).textContent = env.d.toFixed(2)+' s'; });
    envS.addEventListener('input', ()=>{ env.s = parseFloat(envS.value)||0.7; qs('.envSVal', el).textContent = Math.round(env.s*100)+'%'; });
    envR.addEventListener('input', ()=>{ env.r = parseFloat(envR.value)||0.4; qs('.envRVal', el).textContent = env.r.toFixed(2)+' s'; });
    envA.dispatchEvent(new Event('input')); envD.dispatchEvent(new Event('input')); envS.dispatchEvent(new Event('input')); envR.dispatchEvent(new Event('input'));

    // Spectrogram registration
    const spectro = el.querySelector('.spectro');
    const sctx = spectro.getContext('2d', { willReadFrequently: true });
    const specBuf = new Uint8Array(specAnalyser.frequencyBinCount);
    function resizeSpectro(){ const bb = spectro.getBoundingClientRect(); spectro.width = Math.max(320, Math.floor(bb.width)); spectro.height = 90; }
    resizeSpectro(); window.addEventListener('resize', resizeSpectro);
    streamSpectros.push({ analyser:specAnalyser, canvas:spectro, ctx:sctx, buf:specBuf, x:0 });

    // enable drag-reorder if currently in edit mode
    try{ makeStreamDraggable(el, editMode); makeModsDraggable(el.querySelector('.mods'), editMode); }catch(e){}
    return { el };
  }

  // ===== Render loops =====
  function drawBlockScopes(){
    requestAnimationFrame(drawBlockScopes);
    for(const b of blocks){
      const analyser = b.analyser, ctx = b.ctx, cvs = b.cvs;
      const N = analyser.fftSize;
      const buf = new Uint8Array(N);
      analyser.getByteTimeDomainData(buf);
      ctx.clearRect(0,0,cvs.width,cvs.height);
      ctx.strokeStyle = '#59ff85';
      ctx.beginPath();
      for(let i=0;i<buf.length;i++){
        const x = i * (cvs.width / buf.length);
        const scopeGAIN = 2.0; const y = cvs.height/2 + ((buf[i]-128)/128) * (cvs.height/2) * scopeGAIN;
        i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
  }
  function drawStreamSpectros(){
    requestAnimationFrame(drawStreamSpectros);
    for(const s of streamSpectros){
      const { analyser, ctx, canvas, buf } = s;
      analyser.getByteFrequencyData(buf);
      // scroll left by 1 px
      const w = canvas.width, h = canvas.height;
      const img = ctx.getImageData(1, 0, w-1, h);
      ctx.putImageData(img, 0, 0);
      // draw new column at right
      for(let i=0;i<buf.length;i++){
        const mag = buf[i]/255; // 0..1
        const y = Math.floor(h - (i/buf.length)*h);
        ctx.fillStyle = spectroColor(mag);
        ctx.fillRect(w-1, y, 1, Math.ceil(h/buf.length)+1);
      }
    }
  }
  function spectroColor(t){ t = clamp01(t); const r = clamp01(4*t - 1.5)*t; const g = clamp01(4*t - 0.5)*t; const b = clamp01(2 - 4*t)*t; return `rgb(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(b*255)})`; }
  drawBlockScopes();
  drawStreamSpectros();

  // ===== Toolbar wiring =====
  qs('#startAudio').addEventListener('click', ()=>{
    bootAudio();
    ACTX.resume();
  });

  qs('#addBlock').addEventListener('click', ()=> addBlock() );

  // Edit mode: drag blocks
  let editMode = false;
  
  qs('#editToggle').addEventListener('click', (e)=>{
    editMode = !editMode;
    e.target.textContent = editMode ? '✏️ Edit: ON' : '✏️ Edit: OFF';
    e.target.setAttribute('aria-pressed', String(editMode));
    document.body.classList.toggle('edit-on', editMode);
    const toast = qs('#modeToast');
    toast.textContent = editMode ? 'Edit Mode ON — drag blocks with the ⣿ handle.' : 'Edit Mode OFF';
    toast.style.display = 'block';
    setTimeout(()=> toast.style.display='none', 1500);
  });

  
  
  // ---- Error Reporter (for Opera diagnostics) ----
  (function(){
    const box = document.createElement('div');
    box.id = 'errBox';
    box.style.cssText = 'position:fixed;right:8px;bottom:8px;max-width:60ch;background:#300b;border:1px solid #a44;color:#faa;padding:8px 10px;border-radius:6px;font:12px/1.3 system-ui, sans-serif;z-index:9999;display:none';
    document.body.appendChild(box);
    let shown=false;
    window.addEventListener('error', function(e){
      if(shown) return;
      shown=true;
      box.textContent = 'JS error: ' + (e && e.message ? e.message : 'unknown');
      box.style.display = 'block';
      setTimeout(()=> box.style.display='none', 8000);
    });
    window.addEventListener('unhandledrejection', function(e){
      if(shown) return;
      shown=true;
      try{
        box.textContent = 'Promise rejection: ' + (e && (e.reason && (e.reason.message||e.reason)) || 'unknown');
      }catch(_) { box.textContent = 'Promise rejection (unknown)'; }
      box.style.display = 'block';
      setTimeout(()=> box.style.display='none', 8000);
    });
  })();

  // ===== Session Save / Load =====
  function gatherSession(){
    const data = { blocks:[] };
    qsa('.block', main).forEach(blk=>{
      if(isPluginBlock(blk)) return;
      const volEl = qs('.blockVol', blk);
      if(!volEl) return;
      const b = {
        pos: { left: blk.style.left, top: blk.style.top, width: blk.style.width, position: blk.style.position },
        vol: parseFloat(volEl.value)||1,
        streams: []
      };
      qsa('.stream', blk).forEach(st=>{
        const s = {
          ab: parseFloat(qs('.ab', st).value)||0.5,
          vol: parseFloat(qs('.vol', st).value)||0.5,
          pan: parseFloat(qs('.pan', st).value)||0,
          muffleOn: qs('.muffle', st).classList.contains('on'),
          mAmt: parseFloat(qs('.mAmt', st).value)||1,
          tone:{ on: qs('.tone',st).classList.contains('on'), wave: qs('.tWave',st).value, base: parseFloat(qs('.tBase',st).value)||200, beat: parseFloat(qs('.tBeat',st).value)||10, level: parseFloat(qs('.tLevel',st).value)||0.2, preset: qs('.tPreset',st).value },
          noise:{ on: qs('.noise',st).classList.contains('on'), type: qs('.nType',st).value, level: parseFloat(qs('.nLevel',st).value)||0.2, tilt: parseFloat(qs('.nTilt',st).value)||0 },
          eq:{ low: parseFloat(qs('.eqLow',st).value)||0, mid: parseFloat(qs('.eqMid',st).value)||0, high: parseFloat(qs('.eqHigh',st).value)||0 },
          fx:{ mix: parseFloat(qs('.fxMix',st).value)||0, delay: parseFloat(qs('.fxDelay',st).value)||0.25, fb: parseFloat(qs('.fxFb',st).value)||0.3, dist: parseFloat(qs('.fxDist',st).value)||0 },
          lfo:{ on: qs('.lfoOn',st).classList.contains('on'), target: qs('.lfoTarget',st).value, rate: parseFloat(qs('.lfoRate',st).value)||0.5, depth: parseFloat(qs('.lfoDepth',st).value)||0.4 },
          env:{ a: parseFloat(qs('.envA',st).value)||0.01, d: parseFloat(qs('.envD',st).value)||0.2, s: parseFloat(qs('.envS',st).value)||0.7, r: parseFloat(qs('.envR',st).value)||0.4 },
          space:{ preset: qs('.spPreset',st).value, mix: parseFloat(qs('.spMix',st).value)||0, decay: parseFloat(qs('.spDecay',st).value)||1.2, pre: parseFloat(qs('.spPre',st).value)||0 }
        };
        s.files = { A: qs('.aName', st).textContent || '', B: qs('.bName', st).textContent || '' };
        b.streams.push(s);
      });
      data.blocks.push(b);
    });
    return data;
  }
  function applySession(data){
    qsa('.block', main).forEach(b=>{ if(isPluginBlock(b)) return; b.remove(); });
    if(!ACTX){ bootAudio(); ACTX.resume(); }
    (data.blocks||[]).forEach(b=>{
      const blk = addBlock();
      const dom = blocks[blocks.length-1].el;
      if(b.pos){ dom.style.position=b.pos.position||''; dom.style.left=b.pos.left||''; dom.style.top=b.pos.top||''; dom.style.width=b.pos.width||''; }
      const volEl = qs('.blockVol', dom); if(volEl){ volEl.value = b.vol; volEl.dispatchEvent(new Event('input')); }
      const streamsWrap = qs('.streams', dom);
      (b.streams||[]).forEach(s=>{
        const st = createStream(streamsWrap.children.length+1, blocks[blocks.length-1].bus);
        streamsWrap.appendChild(st.el);
        qs('.ab', st.el).value = s.ab; qs('.ab', st.el).dispatchEvent(new Event('input'));
        qs('.vol', st.el).value = s.vol; qs('.vol', st.el).dispatchEvent(new Event('input'));
        qs('.pan', st.el).value = s.pan; qs('.pan', st.el).dispatchEvent(new Event('input'));
        if(s.muffleOn) qs('.muffle', st.el).click();
        qs('.mAmt', st.el).value = s.mAmt; qs('.mAmt', st.el).dispatchEvent(new Event('input'));
        if((s.tone && s.tone.on)) qs('.tone', st.el).click();
        qs('.tWave', st.el).value = (s.tone && s.tone.wave) || 'sine';
        qs('.tPreset', st.el).value = (s.tone && s.tone.preset) || 'custom';
        qs('.tBase', st.el).value = (s.tone && s.tone.base) || 200; qs('.tBase', st.el).dispatchEvent(new Event('input'));
        qs('.tBeat', st.el).value = (s.tone && s.tone.beat) || 10; qs('.tBeat', st.el).dispatchEvent(new Event('input'));
        qs('.tLevel', st.el).value = (s.tone && s.tone.level) || 0.2; qs('.tLevel', st.el).dispatchEvent(new Event('input'));
        if((s.noise && s.noise.on)) qs('.noise', st.el).click();
        qs('.nType', st.el).value = (s.noise && s.noise.type) || 'white';
        qs('.nLevel', st.el).value = (s.noise && s.noise.level) || 0.2; qs('.nLevel', st.el).dispatchEvent(new Event('input'));
        qs('.nTilt', st.el).value = (s.noise && s.noise.tilt) || 0; qs('.nTilt', st.el).dispatchEvent(new Event('input'));
        qs('.eqLow', st.el).value = (s.eq && s.eq.low) || 0; qs('.eqLow', st.el).dispatchEvent(new Event('input'));
        qs('.eqMid', st.el).value = (s.eq && s.eq.mid) || 0; qs('.eqMid', st.el).dispatchEvent(new Event('input'));
        qs('.eqHigh', st.el).value = (s.eq && s.eq.high) || 0; qs('.eqHigh', st.el).dispatchEvent(new Event('input'));
        qs('.fxMix', st.el).value = (s.fx && s.fx.mix) || 0; qs('.fxMix', st.el).dispatchEvent(new Event('input'));
        qs('.fxDelay', st.el).value = (s.fx && s.fx.delay) || 0.25; qs('.fxDelay', st.el).dispatchEvent(new Event('input'));
        qs('.fxFb', st.el).value = (s.fx && s.fx.fb) || 0.3; qs('.fxFb', st.el).dispatchEvent(new Event('input'));
        qs('.fxDist', st.el).value = (s.fx && s.fx.dist) || 0; qs('.fxDist', st.el).dispatchEvent(new Event('input'));
        if((s.lfo && s.lfo.on)) qs('.lfoOn', st.el).click();
        qs('.lfoTarget', st.el).value = (s.lfo && s.lfo.target) || 'pan';
        qs('.lfoRate', st.el).value = (s.lfo && s.lfo.rate) || 0.5; qs('.lfoRate', st.el).dispatchEvent(new Event('input'));
        qs('.lfoDepth', st.el).value = (s.lfo && s.lfo.depth) || 0.4; qs('.lfoDepth', st.el).dispatchEvent(new Event('input'));
        qs('.envA', st.el).value = (s.env && s.env.a) || 0.01; qs('.envA', st.el).dispatchEvent(new Event('input'));
        qs('.envD', st.el).value = (s.env && s.env.d) || 0.2; qs('.envD', st.el).dispatchEvent(new Event('input'));
        qs('.envS', st.el).value = (s.env && s.env.s) || 0.7; qs('.envS', st.el).dispatchEvent(new Event('input'));
        qs('.envR', st.el).value = (s.env && s.env.r) || 0.4; qs('.envR', st.el).dispatchEvent(new Event('input'));
        qs('.spPreset', st.el).value = (s.space && s.space.preset) || 'none'; qs('.spPreset', st.el).dispatchEvent(new Event('change'));
        qs('.spMix', st.el).value = (s.space && s.space.mix) || 0; qs('.spMix', st.el).dispatchEvent(new Event('input'));
        qs('.spDecay', st.el).value = (s.space && s.space.decay) || 1.2; qs('.spDecay', st.el).dispatchEvent(new Event('input'));
        qs('.spPre', st.el).value = (s.space && s.space.pre) || 0; qs('.spPre', st.el).dispatchEvent(new Event('input'));
      });
    });
    enableEditReorder(editMode);
  }

  qs('#saveSession').addEventListener('click', ()=>{
    const blob = new Blob([JSON.stringify(gatherSession(), null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'noisetown_session.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  });

  qs('#loadSession').addEventListener('click', ()=> qs('#loadFile').click());
  qs('#loadFile').addEventListener('change', async (e)=>{
    const file = e.target.files[0]; if(!file) return;
    const txt = await file.text();
    try{ const data = JSON.parse(txt); applySession(data); }catch(err){ alert('Invalid session file'); }
  });

  // ===== Preset with embedded audio (JSON) =====
  function audioBufferToWav(buffer){
    const numCh = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const numFrames = buffer.length;
    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const dataSize = numFrames * blockAlign;
    const bufferSize = 44 + dataSize;
    const ab = new ArrayBuffer(bufferSize);
    const view = new DataView(ab);
    function writeString(off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
    let off = 0;
    writeString(off, 'RIFF'); off+=4;
    view.setUint32(off, 36 + dataSize, true); off+=4;
    writeString(off, 'WAVE'); off+=4;
    writeString(off, 'fmt '); off+=4;
    view.setUint32(off, 16, true); off+=4;
    view.setUint16(off, 1, true); off+=2;
    view.setUint16(off, numCh, true); off+=2;
    view.setUint32(off, sampleRate, true); off+=4;
    view.setUint32(off, sampleRate * blockAlign, true); off+=4;
    view.setUint16(off, blockAlign, true); off+=2;
    view.setUint16(off, 16, true); off+=2;
    writeString(off, 'data'); off+=4;
    view.setUint32(off, dataSize, true); off+=4;
    const interleaved = new Float32Array(numFrames * numCh);
    for(let ch=0; ch<numCh; ch++){
      const data = buffer.getChannelData(ch);
      for(let i=0;i<numFrames;i++){ interleaved[i*numCh+ch] = data[i]; }
    }
    let idx = 0;
    for(let i=0;i<numFrames;i++){
      for(let ch=0; ch<numCh; ch++){
        let s = Math.max(-1, Math.min(1, interleaved[idx++]));
        view.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        off += 2;
      }
    }
    return new Blob([ab], {type:'audio/wav'});
  }
  function blobToBase64(blob){
    return new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result.split(',')[1]); fr.readAsDataURL(blob); });
  }
  function base64ToArrayBuffer(b64){
    const bin = atob(b64); const len = bin.length; const buf = new ArrayBuffer(len); const view = new Uint8Array(buf);
    for(let i=0;i<len;i++) view[i] = bin.charCodeAt(i);
    return buf;
  }

  async function gatherPresetWithAudio(){
    const session = gatherSession();
    let blockIdx = 0;
    const blockEls = qsa('.block', main).filter(blk=> !isPluginBlock(blk));
    for (const blk of blockEls){
      const streams = qsa('.stream', blk);
      let sidx = 0;
      for (const st of streams){
        const scope = session.blocks[blockIdx].streams[sidx];
        scope.audio = scope.audio || {};
        const streamState = st._streamState;
        if(streamState){
          if(streamState.A && streamState.A.buf){
            const blob = audioBufferToWav(streamState.A.buf);
            scope.audio.A = { mime:'audio/wav', base64: await blobToBase64(blob) };
          }
          if(streamState.B && streamState.B.buf){
            const blob = audioBufferToWav(streamState.B.buf);
            scope.audio.B = { mime:'audio/wav', base64: await blobToBase64(blob) };
          }
        }
        sidx++;
      }
      blockIdx++;
    }
    return session;
  }

  qs('#savePreset').addEventListener('click', async ()=>{
    try{
      const preset = await gatherPresetWithAudio();
      const blob = new Blob([JSON.stringify(preset, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'noisetown_preset.json';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }catch(err){ alert('Failed to save preset'); }
  });

  qs('#loadPreset').addEventListener('click', ()=> qs('#loadPresetFile').click());
  qs('#loadPresetFile').addEventListener('change', async (e)=>{
    const file = e.target.files[0]; if(!file) return;
    try{
      const txt = await file.text(); const data = JSON.parse(txt);
      applySession(data);
      let bidx = 0;
      for(const blk of data.blocks||[]){
        const domBlock = blocks[bidx];
        const streamsWrap = qs('.streams', domBlock.el);
        let sidx = 0;
        for(const s of blk.streams||[]){
          const stEl = streamsWrap.children[sidx];
          if(s.audio){
            if((s.audio && s.audio.A && s.audio.A.base64)){
              const buf = await ACTX.decodeAudioData(base64ToArrayBuffer(s.audio.A.base64));
              stEl._streamState.A = stEl._streamState.A || {};
              stEl._streamState.A.buf = buf; stEl._streamState.A.dur = buf.duration; qs('.aName', stEl).textContent = (s.files && s.files.A) || 'embedded A';
            }
            if((s.audio && s.audio.B && s.audio.B.base64)){
              const buf = await ACTX.decodeAudioData(base64ToArrayBuffer(s.audio.B.base64));
              stEl._streamState.B = stEl._streamState.B || {};
              stEl._streamState.B.buf = buf; stEl._streamState.B.dur = buf.duration; qs('.bName', stEl).textContent = (s.files && s.files.B) || 'embedded B';
            }
          }
          sidx++;
        }
        bidx++;
      }
    }catch(err){ console.error(err); alert('Invalid preset file'); }
  });

  // ===== Style Mode (hover + apply styles + save theme) =====
  let styleMode = false;
  let styleTarget = null;
  const stylePanel = qs('#stylePanel');
  
  
qs('#styleMode').addEventListener('click', (e)=>{
  styleMode = !styleMode;
  e.target.textContent = '🎨 Style Mode: ' + (styleMode?'ON':'OFF');
  e.target.setAttribute('aria-pressed', String(styleMode));
  stylePanel.style.display = styleMode ? 'block' : 'none';
  document.body.classList.toggle('style-on', styleMode);

  // Toggle contenteditable on visible text elements
  const textSel = 'h1,h2,h3,h4,.mod-hdr .name,label,button,.small,span,.block h2';
  if(styleMode){
    qsa(textSel).forEach(el=>{
      if(el.closest('#toolbar') || el.closest('#stylePanel')) return;
      el.setAttribute('contenteditable','true');
      el.setAttribute('data-text-edit','1');
      el.spellcheck = false;
    });
  }else{
    qsa('[contenteditable="true"]').forEach(el=> el.removeAttribute('contenteditable'));
  }

  // toast
  const toast = qs('#modeToast');
  toast.textContent = styleMode ? 'Style Mode ON — hover to pick, click to select, then use the panel.' : 'Style Mode OFF';
  toast.style.display = 'block';
  setTimeout(()=> toast.style.display='none', 1800);
  if(!styleMode){ qsa('.style-hover').forEach(x=>x.classList.remove('style-hover')); styleTarget=null; }
});


  
  
  let hoverEl = null;
  document.addEventListener('mouseover', (ev)=>{
    if(!styleMode) return;
    if(ev.target.closest('#stylePanel') || ev.target.closest('#toolbar')) return;
    if(hoverEl) hoverEl.classList.remove('style-hover');
    hoverEl = ev.target;
    hoverEl.classList.add('style-hover');
  }, true);


  
  
  
document.addEventListener('click', (ev)=>{
  if(!styleMode) return;
  if(ev.target.closest('#stylePanel') || ev.target.closest('#toolbar')) return;
  if(ev.target.closest('[contenteditable="true"]')) return; // allow text editing
  // Lock selection to the last hovered element
  if(hoverEl){ styleTarget = hoverEl; }
  ev.preventDefault();
  ev.stopPropagation();
}, true);

  // ESC clears selection
  document.addEventListener('keydown', (ev)=>{
    if(!styleMode) return;
    if(ev.key === 'Escape'){ styleTarget=null; }
  });


  qs('#styApply').addEventListener('click', ()=>{
    if(!styleTarget) return alert('Hover and click an element first to select it.');
    const preset = qs('#stylePreset').value;
    const radius = parseInt(qs('#styRadius').value, 10);
    const shadow = parseInt(qs('#styShadow').value, 10);
    const scope = qs('#styScope').value;

    const css = {};
    if(preset==='bevel'){ css.borderRadius = radius+'px'; css.boxShadow = `inset 1px 1px 0 #fff1, inset -1px -1px 0 #0008`; }
    else if(preset==='shadow'){ css.borderRadius = radius+'px'; css.boxShadow = `${shadow}px ${shadow}px ${Math.max(10,shadow)}px #0008`; }
    else if(preset==='soft'){ css.borderRadius = radius+'px'; css.boxShadow = `0 2px 10px #000a`; }
    else if(preset==='glow'){ css.borderRadius = radius+'px'; css.boxShadow = `0 0 ${Math.max(8,shadow)}px #59a7ff88`; }
    else if(preset==='flat'){ css.borderRadius = radius+'px'; css.boxShadow = 'none'; }
    else { css.borderRadius = radius+'px'; css.boxShadow = `${shadow}px ${shadow}px ${Math.max(10,shadow)}px #0006`; }

    const applyTo = (el)=>{ for(const k in css){ el.style[k] = css[k]; } };
    if(scope==='element'){ applyTo(styleTarget); }
    else if(scope==='stream'){ let p=styleTarget; while(p && !(p.classList && p.classList.contains('stream'))) p=p.parentElement; if(p) applyTo(p); }
    else if(scope==='block'){ let p=styleTarget; while(p && !(p.classList && p.classList.contains('block'))) p=p.parentElement; if(p) applyTo(p); }
    else if(scope==='global'){ qsa('body *').forEach(el=>applyTo(el)); }
  });

  
qs('#stySaveTheme').addEventListener('click', ()=>{
  // Collect inline styles as theme JSON
  const themed = [];
  qsa('body *').forEach(el=>{
    const s = el.getAttribute('style');
    if(s) themed.push({ selector: getDomPath(el), style: s });
  });
  // Collect CSS vars and user CSS
  const varNames = ['--bg','--panel','--card','--text','--muted','--accent','--select','--select-border'];
  const varsOut = {}; varNames.forEach(n=> varsOut[n] = getComputedStyle(document.documentElement).getPropertyValue(n).trim());
  const userCSS = (document.getElementById('userThemeCSS')?.textContent || '');

  // Collect edited texts
  const texts = [];
  qsa('[data-text-edit="1"]').forEach(el=>{
    texts.push({ selector: getDomPath(el), html: el.innerHTML });
  });

  const blob = new Blob([JSON.stringify({ vars: varsOut, userCSS, theme: themed, texts }, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'noisetown_theme.json';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
});
  // ===== Theme Editor (CSS variables, custom CSS, save/load) =====
  const root = document.documentElement;
  const userCssTag = document.getElementById('userThemeCSS') || (()=>{ const t=document.createElement('style'); t.id='userThemeCSS'; document.head.appendChild(t); return t; })();

  // Baselines to support Reset
  let THEME_BASELINE = null;
  let INLINE_BASELINE = null;

  function getDomPath(el){
    if(!el || el===document.body) return 'body';
    const ix = Array.from(el.parentNode.children).indexOf(el)+1;
    return getDomPath(el.parentNode) + ' > ' + el.tagName.toLowerCase() + `:nth-child(${ix})`;
  }
  function snapshotInline(){
    const arr = [];
    qsa('body *').forEach(el=>{
      const s = el.getAttribute('style');
      if(s) arr.push({ selector: getDomPath(el), style: s });
    });
    return arr;
  }
  function captureBaseline(){
    const varNames = ['--bg','--panel','--card','--text','--muted','--accent','--select','--select-border'];
    const varsOut = {};
    varNames.forEach(n=> varsOut[n] = getComputedStyle(root).getPropertyValue(n).trim());
    THEME_BASELINE = { vars: varsOut, userCSS: userCssTag.textContent || '' };
    INLINE_BASELINE = snapshotInline();
  }
  captureBaseline();

  function addThemeControls(){
    const vars = ['--bg','--panel','--card','--text','--muted','--accent','--select','--select-border'];
    const sectionHdr = ce('div'); sectionHdr.className='subhdr'; sectionHdr.textContent='Theme Colors (CSS Variables)';
    stylePanel.insertBefore(sectionHdr, qs('#styApply').parentElement);

    const grid = ce('div'); grid.className='grid';
    vars.forEach(v=>{
      const lab = ce('label'); lab.textContent = v;
      const inp = ce('input'); inp.type='color';
      const cur = getComputedStyle(root).getPropertyValue(v).trim() || '#000000';
      inp.value = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(cur) ? cur : '#000000';
      inp.dataset.var = v;
      inp.addEventListener('input', e=> root.style.setProperty(v, e.target.value));
      grid.appendChild(lab); grid.appendChild(inp);
    });
    stylePanel.insertBefore(grid, qs('#styApply').parentElement);

    const cssHdr = ce('div'); cssHdr.className='subhdr'; cssHdr.textContent='Custom CSS (live)';
    const cssRow = ce('div'); cssRow.className='row wrap';
    const cssTa = ce('textarea'); cssTa.id='userCssText'; cssTa.placeholder='/* Example */\n.stream{ background: #2a2a2a; }';
    cssRow.appendChild(cssTa);
    const cssBtns = ce('div'); cssBtns.className='row';
    const applyCssBtn = ce('button'); applyCssBtn.className='btn'; applyCssBtn.textContent='Apply CSS';
    applyCssBtn.addEventListener('click', ()=>{ userCssTag.textContent = cssTa.value || ''; });
    const loadThemeBtn = ce('button'); loadThemeBtn.className='btn'; loadThemeBtn.textContent='Load Theme JSON';
    loadThemeBtn.style.marginLeft = 'auto';
    const themeFile = ce('input'); themeFile.type='file'; themeFile.accept='application/json'; themeFile.style.display='none';
    loadThemeBtn.addEventListener('click', ()=> themeFile.click());
    
themeFile.addEventListener('change', async (e)=>{
  const f = e.target.files[0]; if(!f) return;
  try{
    const txt = await f.text(); const data = JSON.parse(txt);
    if(data.vars){ Object.entries(data.vars).forEach(([k,v])=> document.documentElement.style.setProperty(k, v)); }
    if(typeof data.userCSS === 'string'){ userCssTag.textContent = data.userCSS; cssTa.value = data.userCSS; }
    // clear inline then apply
    qsa('body *').forEach(el=> el.removeAttribute('style'));
    if(Array.isArray(data.theme)){
      data.theme.forEach(t=>{ try{ const el = document.querySelector(t.selector); if(el && t.style) el.setAttribute('style', t.style); }catch(e){} });
    }
    if(Array.isArray(data.texts)){
      data.texts.forEach(t=>{ try{ const el = document.querySelector(t.selector); if(el && typeof t.html==='string') el.innerHTML = t.html; }catch(e){} });
  }
  }catch(err){ alert('Invalid theme JSON'); }
});
    cssBtns.appendChild(applyCssBtn); cssBtns.appendChild(loadThemeBtn); cssRow.appendChild(cssBtns);
    cssRow.appendChild(themeFile);
    stylePanel.insertBefore(cssHdr, qs('#styApply').parentElement);
    stylePanel.insertBefore(cssRow, qs('#styApply').parentElement);
  }
  addThemeControls();

  // Reset to last baseline
  qs('#styResetTheme').addEventListener('click', ()=>{
    if(!THEME_BASELINE){ alert('No baseline to reset to.'); return; }
    Object.entries(THEME_BASELINE.vars).forEach(([k,v])=> root.style.setProperty(k, v));
    userCssTag.textContent = THEME_BASELINE.userCSS || '';
    const ta = qs('#userCssText'); if(ta) ta.value = THEME_BASELINE.userCSS || '';
    qsa('body *').forEach(el=> el.removeAttribute('style'));
    (INLINE_BASELINE||[]).forEach(t=>{ try{ const el = document.querySelector(t.selector); if(el) el.setAttribute('style', t.style); }catch(e){} });
  });

  // Extend Save Theme JSON -> include CSS variables + custom CSS + inline paint
  const origSave = qs('#stySaveTheme');
  origSave.addEventListener('click', (ev)=>{
    ev.preventDefault();
    const themed = [];
    qsa('body *').forEach(el=>{
      const s = el.getAttribute('style');
      if(s) themed.push({ selector: getDomPath(el), style: s });
    });
    const varNames = ['--bg','--panel','--card','--text','--muted','--accent','--select','--select-border'];
    const varsOut = {};
    varNames.forEach(n=> varsOut[n] = getComputedStyle(root).getPropertyValue(n).trim());
    const payload = {
      vars: varsOut,
      userCSS: (qs('#userCssText') ? qs('#userCssText').value : '')||userCssTag.textContent||'',
      theme: themed
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'noisetown_theme.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  });

  const selInfo = ce('div'); selInfo.className='small'; selInfo.id='stySelInfo'; stylePanel.appendChild(selInfo);
  const updateSelInfo = ()=>{ selInfo.textContent = styleTarget ? ('Target: ' + getDomPath(styleTarget)) : 'Target: (none)'; };
  setInterval(updateSelInfo, 250);

  // ===== Edit-mode reordering for Streams and Mods =====
  function enableEditReorder(enabled){
    qsa('.stream').forEach(s=> makeStreamDraggable(s, enabled));
    qsa('.mods').forEach(m=> makeModsDraggable(m, enabled));
  }

  function makeStreamDraggable(streamEl, enabled){
    streamEl.draggable = !!enabled;
    const header = streamEl.querySelector('h3');
    if(!header) return;
    header.style.cursor = enabled ? 'move' : '';
    streamEl.addEventListener('dragstart', (e)=>{
      if(!enabled) return;
      streamEl.classList.add('draggingItem');
      e.dataTransfer.effectAllowed='move';
      const ph = document.createElement('div'); ph.className='placeholder'; ph.style.height = streamEl.getBoundingClientRect().height+'px';
      streamEl.parentElement.insertBefore(ph, streamEl.nextSibling);
      e.dataTransfer.setData('text/plain', 'stream');
    });
    streamEl.addEventListener('dragend', (e)=>{
      streamEl.classList.remove('draggingItem');
      streamEl.parentElement.querySelectorAll('.placeholder').forEach(x=>x.remove());
    });
    const container = streamEl.parentElement;
    if(container && !container._dndBound){
      container._dndBound = true;
      container.addEventListener('dragover', (e)=>{
        if(!enabled) return;
        e.preventDefault();
        const dragging = container.querySelector('.draggingItem');
        if(!dragging) return;
        const after = getDragAfterElement(container, e.clientY);
        const ph = container.querySelector('.placeholder');
        if(after==null) container.appendChild(ph);
        else container.insertBefore(ph, after);
      });
      container.addEventListener('drop', (e)=>{
        if(!enabled) return;
        e.preventDefault();
        const ph = container.querySelector('.placeholder');
        const dragging = container.querySelector('.draggingItem');
        if(ph && dragging){ container.insertBefore(dragging, ph); ph.remove(); }
      });
    }
  }

  function makeModsDraggable(modsContainer, enabled){
    modsContainer.querySelectorAll('.mod').forEach(mod=>{
      const hdr = mod.querySelector('.mod-hdr');
      mod.draggable = !!enabled;
      if(hdr) hdr.style.cursor = enabled ? 'move' : '';
      mod.addEventListener('dragstart', (e)=>{
        if(!enabled) return;
        mod.classList.add('draggingItem');
        e.dataTransfer.effectAllowed='move';
        const ph = document.createElement('div'); ph.className='placeholder'; ph.style.height = mod.getBoundingClientRect().height+'px';
        mod.parentElement.insertBefore(ph, mod.nextSibling);
      });
      mod.addEventListener('dragend', ()=>{
        mod.classList.remove('draggingItem');
        mod.parentElement.querySelectorAll('.placeholder').forEach(x=>x.remove());
      });
    });
    if(!modsContainer._dndBound){
      modsContainer._dndBound = true;
      modsContainer.addEventListener('dragover', (e)=>{
        if(!enabled) return; e.preventDefault();
        const dragging = modsContainer.querySelector('.draggingItem');
        if(!dragging) return;
        const after = getDragAfterElement(modsContainer, e.clientY);
        const ph = modsContainer.querySelector('.placeholder');
        if(after==null) modsContainer.appendChild(ph);
        else modsContainer.insertBefore(ph, after);
      });
      modsContainer.addEventListener('drop', (e)=>{
        if(!enabled) return; e.preventDefault();
        const ph = modsContainer.querySelector('.placeholder');
        const dragging = modsContainer.querySelector('.draggingItem');
        if(ph && dragging){ modsContainer.insertBefore(dragging, ph); ph.remove(); }
      });
    }
  }

  function getDragAfterElement(container, y){
    const els = [...container.querySelectorAll(':scope > :not(.placeholder):not(.draggingItem)')];
    let closest = {offset: Number.NEGATIVE_INFINITY, element: null};
    for(const child of els){
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height/2;
      if(offset < 0 && offset > closest.offset) closest = {offset, element: child};
    }
    return closest.element;
  }

  // When Edit toggles, (re)enable drag
  const _editBtn = qs('#editToggle');
  _editBtn.addEventListener('click', ()=> enableEditReorder(editMode));

  // Also enable on newly created streams
  // Start with one block for convenience and keep the external workspace present
  ensurePluginRack();
  addBlock();
})();

</script>

<script>
// === Style Preset wiring (add 9x themes) ===
(function(){
  const sel = document.getElementById('stylePreset');
  if(!sel) return;
  function setThemeClass(name){
    document.body.classList.remove('theme-98','theme-xp');
    if(name==='win98'){ document.body.classList.add('theme-98'); }
    else if(name==='winxp'){ document.body.classList.add('theme-xp'); }
  }
  sel.addEventListener('change', ()=>{
    setThemeClass(sel.value);
  });
  // ensure current applies on load if selected
  setThemeClass(sel.value);
})();

function applyMod(target, s, ctx){
  const el = ctx.el;
  const sample = ctx.sample;
  const clamp01 = v=>Math.min(1,Math.max(0,v));
  try{
    switch(target){
      case 'pan': ctx.pan.pan.value = Math.max(-1, Math.min(1, s * (ctx.lfo.depth||0))); el.querySelector('.pan').value = ctx.pan.pan.value; el.querySelector('.pan').dispatchEvent(new Event('input', {bubbles:true})); break;
      case 'vol': const v = clamp01(0.5 + s*(ctx.lfo.depth||0)); ctx.out.gain.value = v; break;
      case 'lpf': const hz = 500 + (1+s)*9750; ctx.lpf.frequency.value = hz; break;
      case 'tempo': sample.tempo = clamp01(0.5 + s*(ctx.lfo.depth||0.5))*2; break;
      case 'pitch': sample.pitch = Math.round(s*(ctx.lfo.depth||0.5)*12); break;
      case 'ab': const mix = clamp01(0.5 + s*(ctx.lfo.depth||0.5)); el.querySelector('.ab').value = mix; el.querySelector('.ab').dispatchEvent(new Event('input',{bubbles:true})); break;
      case 'apos': sample.A.offset = clamp01(sample.A.offset + s*0.001); break;
      case 'bpos': sample.B.offset = clamp01(sample.B.offset + s*0.001); break;
    }
  }catch(e){ /* no-op */ }
}

function makeLfoTick(ctx){
  return function lfoTick(ts){
    const lfo = ctx.lfo;
    if(!lfo.enabled) return;
    const t = (ts - (lfo.t0||0))/1000;
    let s = Math.sin(2*Math.PI*lfo.rate * t);
    if(lfo.wave==='square') s = Math.sign(s);
    else if(lfo.wave==='tri') s = (2/Math.PI)*Math.asin(s);
    else if(lfo.wave==='saw'){ const u=(t*lfo.rate)%1; s=2*u-1; }
    applyMod(lfo.target, s*(lfo.depth||0.5), ctx);

    // Simple S&H on top if enabled
    const sh = ctx.sh;
    if(sh && sh.enabled){
      const dt = (ts - (sh.t0||0))/1000;
      if(!sh.tPrev || (dt - sh.tPrev) > (1/Math.max(0.1, sh.rate||2))){
        sh.tPrev = dt; sh.val = (Math.random()*2-1) * (sh.depth||0.25);
      }
      applyMod(sh.target||lfo.target, sh.val||0, ctx);
    }
  }
}

// Global emoji stripper
(function(){
  const emojiRE=/[\u{1F300}-\u{1FAFF}\u{2700}-\u{27BF}\u{2600}-\u{26FF}]/gu;
  function strip(node){
    const w=document.createTreeWalker(node,NodeFilter.SHOW_TEXT,null);
    const t=[]; while(w.nextNode()){ const n=w.currentNode; if(emojiRE.test(n.nodeValue)) t.push(n); }
    t.forEach(n=> n.nodeValue=n.nodeValue.replace(emojiRE,''));
  }
  const body=document.body; strip(body);
  new MutationObserver(()=>strip(body)).observe(body,{childList:true,subtree:true,characterData:true});
})();
// === Theme preset application (Flat / Win98 / WinXP) ===
(function(){
  function applyPreset(name){
    document.body.classList.remove('theme-98','theme-xp');
    if(name==='win98'){ document.body.classList.add('theme-98'); }
    else if(name==='winxp'){ document.body.classList.add('theme-xp'); }
    else {/* flat -> no extra class */}
    // Default fonts & vars
    if(name==='win98'){
      document.documentElement.style.setProperty('--bg','#008080');
      document.body.style.backgroundColor = '#008080';
      document.body.style.backgroundImage = 'none';
      document.body.style.fontFamily = "MS Sans Serif, Tahoma, sans-serif";
    }else if(name==='winxp'){
      document.body.style.fontFamily = "Tahoma, Verdana, sans-serif";
      // If user wants wallpaper, they can set via Style Panel BG; otherwise gradient stays.
    }
  }
  window.applyPreset = applyPreset;
  const sp = document.getElementById('stylePreset');
  if(sp){
    sp.addEventListener('change', (e)=>{
      const v = e.target.value;
      if(v==='win98' || v==='winxp' || v==='flat') applyPreset(v);
    });
    // initialize from current selection
    if(sp.value==='win98' || sp.value==='winxp' || sp.value==='flat') applyPreset(sp.value);
  }
})();

// === Style Panel: Assets (slider images + background) ===
(function(){
  const stylePanel = document.getElementById('stylePanel');
  if(!stylePanel) return;
  function mk(html){ const d=document.createElement('div'); d.innerHTML=html.trim(); return d.firstChild; }
  const grp = mk(`
    <div class="group">
      <div class="h">Assets (images)</div>
      <div class="row wrap" style="gap:8px">
        <label>Slider Track</label>
        <input id="imgTrackFile" type="file" accept="image/*">
        <input id="imgTrackUrl" type="text" placeholder="or paste image URL" style="width:220px">
        <label>Scale</label><input id="imgTrackScale" type="number" step="0.1" value="1" style="width:70px">
        <label>Rotate</label><input id="imgTrackRotate" type="number" step="1" value="0" style="width:70px">
      </div>
      <div class="row wrap" style="gap:8px">
        <label>Slider Thumb</label>
        <input id="imgThumbFile" type="file" accept="image/*">
        <input id="imgThumbUrl" type="text" placeholder="or paste image URL" style="width:220px">
        <label>Scale</label><input id="imgThumbScale" type="number" step="0.1" value="1" style="width:70px">
        <label>Rotate</label><input id="imgThumbRotate" type="number" step="1" value="0" style="width:70px">
      </div>
      <div class="row wrap" style="gap:8px">
        <label>Background image</label>
        <input id="imgBgFile" type="file" accept="image/*">
        <input id="imgBgUrl" type="text" placeholder="or paste image URL" style="width:220px">
        <button class="btn" id="imgBgApply">Apply BG</button>
        <button class="btn" id="imgBgClear">Clear BG</button>
      </div>
    </div>`);
  stylePanel.appendChild(grp);

  // Helpers
  function fileToDataURL(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }
  async function applyImgVar(fromFileEl, fromUrlEl, varName){
    try{
      let url = (fromUrlEl && fromUrlEl.value.trim()) || "";
      if(fromFileEl && fromFileEl.files && fromFileEl.files[0]) url = await fileToDataURL(fromFileEl.files[0]);
      if(!url) return; document.documentElement.style.setProperty(varName, `url("${url}")`);
    }catch(e){ console.warn('img var apply failed', varName, e); }
  }
  function setNumVar(id, cssVar, unit=""){ const el=document.getElementById(id); if(!el) return; const v=parseFloat(el.value)||0; document.documentElement.style.setProperty(cssVar, v+(unit||"")); }

  const tF=document.getElementById('imgTrackFile'), tU=document.getElementById('imgTrackUrl');
  const thF=document.getElementById('imgThumbFile'), thU=document.getElementById('imgThumbUrl');
  const bgF=document.getElementById('imgBgFile'), bgU=document.getElementById('imgBgUrl');
  const bgApply=document.getElementById('imgBgApply'), bgClear=document.getElementById('imgBgClear');

  [tF,tU].forEach(el=> el&&el.addEventListener('change',()=> applyImgVar(tF,tU,'--slider-track-img')));
  [thF,thU].forEach(el=> el&&el.addEventListener('change',()=> applyImgVar(thF,thU,'--slider-thumb-img')));
  document.getElementById('imgTrackScale')?.addEventListener('change', ()=> setNumVar('imgTrackScale','--slider-track-scale'));
  document.getElementById('imgTrackRotate')?.addEventListener('change', ()=> setNumVar('imgTrackRotate','--slider-track-rotate','deg'));
  document.getElementById('imgThumbScale')?.addEventListener('change', ()=> setNumVar('imgThumbScale','--slider-thumb-scale'));
  document.getElementById('imgThumbRotate')?.addEventListener('change', ()=> setNumVar('imgThumbRotate','--slider-thumb-rotate','deg'));

  bgApply?.addEventListener('click', async ()=>{
    await applyImgVar(bgF,bgU,'--_tmp');
    const val=getComputedStyle(document.documentElement).getPropertyValue('--_tmp').trim();
    if(val) document.body.style.backgroundImage = val;
  });
  bgClear?.addEventListener('click', ()=>{ document.body.style.backgroundImage=''; });
})();

// XP Start button + window controls (idempotent)
(function(){
  function ensureStartButton(){
    const tb = document.getElementById('toolbar');
    if(!tb || document.getElementById('xpStart')) return;
    // wrap inner
    if(!document.getElementById('toolbarInner')){
      const inn = document.createElement('div'); inn.id='toolbarInner';
      while(tb.firstChild){ inn.appendChild(tb.firstChild); }
      tb.appendChild(inn);
    }
    const start = document.createElement('div');
    start.id = 'xpStart';
    start.innerHTML = '<span class="xpLogo"></span><span>Start</span>';
    tb.insertBefore(start, tb.firstChild);
  }

  function ensureWinControls(){
    document.querySelectorAll('.mod-hdr').forEach(hdr=>{
      if(hdr.querySelector('.win-ctl')) return;
      const ctl = document.createElement('div'); ctl.className='win-ctl';
      const bMin = document.createElement('div'); bMin.className='btnctl min'; bMin.title='Minimize';
      const bMax = document.createElement('div'); bMax.className='btnctl max'; bMax.title='Maximize';
      const bCls = document.createElement('div'); bCls.className='btnctl cls'; bCls.title='Close';
      ctl.append(bMin, bMax, bCls); hdr.appendChild(ctl);

      const mod = hdr.closest('.mod');
      // minimize -> toggle open/collapsed
      bMin.addEventListener('click', (e)=>{ e.stopPropagation(); mod.classList.toggle('open'); });
      // maximize -> toggle maximized
      bMax.addEventListener('click', (e)=>{ e.stopPropagation(); mod.classList.toggle('maximized'); });
      // close -> hide
      bCls.addEventListener('click', (e)=>{ e.stopPropagation(); mod.style.display='none'; });
    });
  }

  function onTheme(){
    const isXP = document.body.classList.contains('theme-xp');
    if(isXP){ ensureStartButton(); ensureWinControls(); }
  }
  document.addEventListener('DOMContentLoaded', onTheme);
  window.addEventListener('load', onTheme);

  // Also observe DOM for new modules (e.g., added streams)
  const mo = new MutationObserver(()=> onTheme());
  mo.observe(document.body, {childList:true, subtree:true});
})();

function wireSH(el, ctx){
  const shOn = el.querySelector('.shOn'), shTarget = el.querySelector('.shTarget'),
        shRate = el.querySelector('.shRate'), shDepth = el.querySelector('.shDepth'),
        shSmooth = el.querySelector('.shSmooth'), shQ = el.querySelector('.shQ');
  if(!shOn) return;
  const sh = ctx.sh || (ctx.sh = {enabled:false, target:'pan', rate:2, depth:0.25, smooth:0.1, q:1, t0:performance.now(), tPrev:0, val:0, disp:0});
  shOn.addEventListener('click', ()=>{ sh.enabled=!sh.enabled; shOn.textContent = 'S&H: ' + (sh.enabled?'ON':'OFF'); sh.t0=performance.now(); sh.tPrev=0; });
  shTarget?.addEventListener('change', ()=> sh.target = shTarget.value);
  shRate?.addEventListener('input', ()=>{ sh.rate = parseFloat(shRate.value)||2; el.querySelector('.shRateVal').textContent = sh.rate.toFixed(1)+' Hz'; });
  shDepth?.addEventListener('input', ()=>{ sh.depth = parseFloat(shDepth.value)||0.25; el.querySelector('.shDepthVal').textContent = Math.round(sh.depth*100)+'%'; });
  shSmooth?.addEventListener('input', ()=>{ sh.smooth = parseFloat(shSmooth.value)||0; el.querySelector('.shSmoothVal').textContent = sh.smooth.toFixed(2); });
  shQ?.addEventListener('change', ()=>{ sh.q = Math.max(1, Math.floor(parseFloat(shQ.value)||1)); });
  shRate?.dispatchEvent(new Event('input')); shDepth?.dispatchEvent(new Event('input')); shSmooth?.dispatchEvent(new Event('input'));
  ctx._ticks = ctx._ticks || [];
  ctx._ticks.push(function shTick(ts){
    if(!sh.enabled) return;
    const dt=(ts - (sh.t0||0))/1000;
    if(dt - (sh.tPrev||0) >= (1/Math.max(0.1, sh.rate))){
      sh.tPrev = dt;
      let v = Math.random()*2 - 1;
      if(sh.q>1){ v = Math.round(v*sh.q)/sh.q; }
      sh.val = v * (sh.depth||0);
    }
    sh.disp += (sh.val - sh.disp) * (sh.smooth||0);
    applyMod(sh.target, sh.disp, ctx);
  });
}

function wireEnvelope(el, ctx){
  const env = ctx.env || (ctx.env = {enabled:false, target:'vol', atk:0.02, rel:0.2, depth:0.8, rms:0});
  const on = el.querySelector('.envOn'), tar = el.querySelector('.envTarget'),
        atk = el.querySelector('.envAtk'), rel = el.querySelector('.envRel'), dep = el.querySelector('.envDepth');
  if(!on) return;
  on.addEventListener('click', ()=>{ env.enabled = !env.enabled; on.textContent = 'Envelope: ' + (env.enabled?'ON':'OFF'); });
  tar?.addEventListener('change', ()=> env.target = tar.value);
  atk?.addEventListener('input', ()=> env.atk = parseFloat(atk.value)||0.02);
  rel?.addEventListener('input', ()=> env.rel = parseFloat(rel.value)||0.2);
  dep?.addEventListener('input', ()=> env.depth = parseFloat(dep.value)||0.8);
  ctx._ticks = ctx._ticks || [];
  if(!ctx.an){ ctx.an = ctx.actx.createAnalyser(); ctx.an.fftSize = 256; if(ctx.out) ctx.out.connect(ctx.an); }
  const buf = new Uint8Array(128);
  ctx._ticks.push(function envTick(ts){
    if(!env.enabled || !ctx.an) return;
    ctx.an.getByteTimeDomainData(buf);
    let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
    const rms = Math.sqrt(sum/buf.length);
    const coeff = (rms>env.rms? env.atk: env.rel);
    env.rms += (rms - env.rms) * coeff;
    const s = env.rms * (env.depth||1);
    applyMod(env.target, s, ctx);
  });
}

function wireGate(el, ctx){
  const gt = ctx.gate || (ctx.gate={enabled:false, steps:Array(8).fill(1), rate:'1/8', depth:1, idx:0, t0:performance.now(), tPrev:0});
  const on = el.querySelector('.gateOn'), box = el.querySelector('.gateSteps'),
        rate = el.querySelector('.gateRate'), dep = el.querySelector('.gateDepth');
  if(!on) return;
  if(box && !box.childElementCount){ for(let i=0;i<8;i++){ const b=document.createElement('button'); b.className='btn xs'; b.textContent=gt.steps[i]?'■':'□'; b.addEventListener('click', ()=>{ gt.steps[i]=gt.steps[i]?0:1; b.textContent=gt.steps[i]?'■':'□'; }); box.appendChild(b); } }
  on.addEventListener('click', ()=>{ gt.enabled=!gt.enabled; on.textContent='Gate: '+(gt.enabled?'ON':'OFF'); gt.t0=performance.now(); gt.tPrev=0; });
  rate?.addEventListener('change', ()=> gt.rate = rate.value);
  dep?.addEventListener('input', ()=> gt.depth = parseFloat(dep.value)||1);
  ctx._ticks = ctx._ticks || [];
  ctx._ticks.push(function gateTick(ts){
    if(!gt.enabled) return;
    const spb = 60/Math.max(20, window._GLOBAL_TEMPO||120);
    const div = gt.rate==='1/16'?4: (gt.rate==='1/4'?1:2);
    const stepDur = spb/div;
    const dt = (ts - gt.t0)/1000;
    if(dt - (gt.tPrev||0) >= stepDur){ gt.tPrev += stepDur; gt.idx = (gt.idx+1)%gt.steps.length; }
    const mult = gt.steps[gt.idx]? (1 - (gt.depth||1)) : 1;
    if(ctx.out) ctx.out.gain.setValueAtTime(mult, ctx.actx.currentTime);
  });
}

let __MOD_TICKS = [];
function ensureModLoop(){
  if(ensureModLoop._on) return;
  ensureModLoop._on = true;
  function raf(ts){
    for(const fn of __MOD_TICKS){ try{ fn(ts); }catch(e){} }
    requestAnimationFrame(raf);
  }
  requestAnimationFrame(raf);
}

function bootWireMods(root){
  (root||document).querySelectorAll('.mod.modulation').forEach(mod=>{
    const container = mod.closest('.stream, .block, .stream1, [data-stream]') || document;
    const ctx = container._ctx || (container._ctx = { el:container, actx: (window.ACTX || (window.ACTX = new (window.AudioContext||window.webkitAudioContext)())), out: window._MASTER_OUT, tempo: window._GLOBAL_TEMPO||120 });
    wireSH(mod, ctx); wireEnvelope(mod, ctx); wireGate(mod, ctx);
    if(ctx._ticks) __MOD_TICKS.push(...ctx._ticks);
  });
  ensureModLoop();
}
document.addEventListener('DOMContentLoaded', ()=> bootWireMods(document));
new MutationObserver(m=> m.forEach(r=> r.addedNodes && r.addedNodes.forEach(n=> n.nodeType===1 && bootWireMods(n)))).observe(document.body,{childList:true,subtree:true});

// Uniform Mod Extensions — minimal and namespaced to avoid collisions.
(function(){
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function applyToTarget(target, s, ctx){
    if(typeof window.applyMod === 'function'){ try{ window.applyMod(target, s, ctx); return; }catch(e){} }
    try{
      if(target==='vol' && ctx.out){ ctx.out.gain.value = clamp01(0.5 + s); }
      else if(target==='pan' && ctx.pan){ ctx.pan.pan.value = Math.max(-1, Math.min(1, s)); }
      else if(target==='lpf' && ctx.lpf){ ctx.lpf.frequency.value = 500 + (1+s)*9750; }
    }catch(_){}
  }

  function wireSH(mod, ctx){
    const elOn = mod.querySelector('.shOn'); if(!elOn) return;
    const st = { enabled:false, target:'pan', rate:2, depth:0.25, smooth:0.1, q:1, t0:performance.now(), tPrev:0, val:0, disp:0 };
    const target = mod.querySelector('.shTarget');
    const rate = mod.querySelector('.shRate');
    const depth = mod.querySelector('.shDepth');
    const smooth = mod.querySelector('.shSmooth');
    const q = mod.querySelector('.shQ');
    elOn.addEventListener('click', ()=>{ st.enabled=!st.enabled; elOn.textContent='S&H: '+(st.enabled?'ON':'OFF'); st.t0=performance.now(); st.tPrev=0; });
    target && target.addEventListener('change', ()=> st.target = target.value);
    rate && rate.addEventListener('input', ()=>{ st.rate = parseFloat(rate.value)||2; const v = mod.querySelector('.shRateVal'); if(v) v.textContent = st.rate.toFixed(1)+' Hz'; });
    depth && depth.addEventListener('input', ()=>{ st.depth = parseFloat(depth.value)||0.25; const v = mod.querySelector('.shDepthVal'); if(v) v.textContent = Math.round(st.depth*100)+'%'; });
    smooth && smooth.addEventListener('input', ()=>{ st.smooth = parseFloat(smooth.value)||0; const v = mod.querySelector('.shSmoothVal'); if(v) v.textContent = (st.smooth).toFixed(2); });
    q && q.addEventListener('change', ()=> st.q = Math.max(1, Math.floor(parseFloat(q.value)||1)) );
    (ctx._ticks||(ctx._ticks=[])).push(function shTick(ts){
      if(!st.enabled) return;
      const dt=(ts - st.t0)/1000;
      if(dt - (st.tPrev||0) >= (1/Math.max(0.1, st.rate))){
        st.tPrev = dt;
        let v = Math.random()*2 - 1;
        if(st.q>1) v = Math.round(v*st.q)/st.q;
        st.val = v * (st.depth||0);
      }
      st.disp += (st.val - st.disp) * (st.smooth||0);
      applyToTarget(st.target||'pan', st.disp, ctx);
    });
  }

  function wireEnvelope(mod, ctx){
    const on = mod.querySelector('.envOn'); if(!on) return;
    const env = {enabled:false, target:'vol', atk:0.02, rel:0.2, depth:0.8, rms:0};
    const tar = mod.querySelector('.envTarget');
    const atk = mod.querySelector('.envAtk');
    const rel = mod.querySelector('.envRel');
    const dep = mod.querySelector('.envDepth');
    on.addEventListener('click', ()=>{ env.enabled=!env.enabled; on.textContent='Envelope: '+(env.enabled?'ON':'OFF'); });
    tar && tar.addEventListener('change', ()=> env.target = tar.value);
    atk && atk.addEventListener('input', ()=> env.atk = parseFloat(atk.value)||0.02);
    rel && rel.addEventListener('input', ()=> env.rel = parseFloat(rel.value)||0.2);
    dep && dep.addEventListener('input', ()=> env.depth = parseFloat(dep.value)||0.8);
    try{
      const actx = ctx.actx || (window.AudioContext? new AudioContext(): null);
      if(actx && ctx.out){
        ctx.__env_an = ctx.__env_an || actx.createAnalyser(); ctx.__env_an.fftSize = 256;
        ctx.out.connect(ctx.__env_an);
        const buf = new Uint8Array(128);
        (ctx._ticks||(ctx._ticks=[])).push(function envTick(){
          if(!env.enabled) return;
          ctx.__env_an.getByteTimeDomainData(buf);
          let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
          const rms = Math.sqrt(sum/buf.length);
          const coeff = (rms>env.rms? env.atk: env.rel);
          env.rms += (rms - env.rms) * coeff;
          const s = env.rms * (env.depth||1);
          applyToTarget(env.target, s, ctx);
        });
      }
    }catch(_){}
  }

  function wireGate(mod, ctx){
    const on = mod.querySelector('.gateOn'); if(!on) return;
    const box = mod.querySelector('.gateSteps');
    const rate = mod.querySelector('.gateRate');
    const dep = mod.querySelector('.gateDepth');
    const gt = {enabled:false, steps:Array(8).fill(1), rate:'1/8', depth:1, idx:0, t0:performance.now(), tPrev:0};
    if(box && !box.childElementCount){
      for(let i=0;i<8;i++){ const b=document.createElement('button'); b.className='btn btn-xs'; b.textContent=gt.steps[i]?'■':'□'; b.addEventListener('click', ()=>{ gt.steps[i]=gt.steps[i]?0:1; b.textContent=gt.steps[i]?'■':'□'; }); box.appendChild(b); }
    }
    on.addEventListener('click', ()=>{ gt.enabled=!gt.enabled; on.textContent='Gate: '+(gt.enabled?'ON':'OFF'); gt.t0=performance.now(); gt.tPrev=0; });
    rate && rate.addEventListener('change', ()=> gt.rate = rate.value);
    dep && dep.addEventListener('input', ()=> gt.depth = parseFloat(dep.value)||1);
    (ctx._ticks||(ctx._ticks=[])).push(function gateTick(ts){
      if(!gt.enabled) return;
      const tempo = window._GLOBAL_TEMPO || ctx.tempo || 120;
      const spb = 60/Math.max(20, tempo);
      const div = gt.rate==='1/16'?4: (gt.rate==='1/4'?1:2);
      const stepDur = spb/div;
      const dt = (ts - gt.t0)/1000;
      if(dt - (gt.tPrev||0) >= stepDur){ gt.tPrev += stepDur; gt.idx = (gt.idx+1)%gt.steps.length; }
      const mult = gt.steps[gt.idx]? (1 - (gt.depth||1)) : 1;
      if(ctx.out && ctx.actx){ try{ ctx.out.gain.setValueAtTime(mult, ctx.actx.currentTime); }catch(_){ ctx.out.gain.value = mult; } }
    });
  }

  function wireAll(root){
    (root||document).querySelectorAll('.mod.modulation').forEach(mod=>{
      const container = mod.closest('.stream, .block, .stream1, [data-stream]') || document;
      container._ctx = container._ctx || { el:container, actx: (window.ACTX || (window.ACTX = (window.AudioContext? new AudioContext(): null))), out: window._MASTER_OUT, tempo: window._GLOBAL_TEMPO||120 };
      const ctx = container._ctx;
      wireSH(mod, ctx); wireEnvelope(mod, ctx); wireGate(mod, ctx);
    });
  }

  // tick loop piggybacks existing loops; if none exist, create one
  (function ensureLoop(){
    if(ensureLoop.__on) return; ensureLoop.__on = true;
    function raf(ts){
      document.querySelectorAll('.stream, .block, .stream1, [data-stream]').forEach(n=>{
        const ctx = n._ctx; if(!ctx || !ctx._ticks) return;
        for(const fn of ctx._ticks){ try{ fn(ts); }catch(e){} }
      });
      requestAnimationFrame(raf);
    }
    requestAnimationFrame(raf);
  })();

  document.addEventListener('DOMContentLoaded', ()=> wireAll(document));
  new MutationObserver(m=> m.forEach(r=> r.addedNodes && r.addedNodes.forEach(n=> n.nodeType===1 && wireAll(n)))).observe(document.body,{childList:true,subtree:true});
})();
</script>

<script id="mods-advanced-v1">
(function(){
  if (window.__NT_MODS_ADV__) return; window.__NT_MODS_ADV__ = true;

  const CLAMP01 = v => Math.max(0, Math.min(1, v));
  const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  const TICKERS = [];

  (function loop(t){
    for (let i=0;i<TICKERS.length;i++){ try{ TICKERS[i](t); }catch(e){} }
    requestAnimationFrame(loop);
  })(0);

  function applyTo(target, value, ctx){
    // Allow user hook first
    if (typeof window.applyMod === 'function'){
      try { window.applyMod(target, value, ctx); return; } catch(e){}
    }
    try {
      if (target === 'vol'  && ctx && ctx.out) {
        ctx.out.gain.value = Math.max(0, Math.min(1, 0.5 + value));
      } else if (target === 'pan'  && ctx && ctx.pan) {
        ctx.pan.pan.value = Math.max(-1, Math.min(1, value));
      } else if (target === 'lpf'  && ctx && (ctx.lpf || ctx.lpfA || ctx.lpfB)) {
        const f = 500 + (1+value)*9750;
        if (ctx.lpf)  ctx.lpf.frequency.value  = f;
        if (ctx.lpfA) ctx.lpfA.frequency.value = f;
        if (ctx.lpfB) ctx.lpfB.frequency.value = f;
      } else if (target === 'ab'   && ctx && ctx.ab) {
        const v = Math.max(0, Math.min(1, 0.5 + value*0.5));
        ctx.ab.gain.value = v;
      } else if (target === 'tempo' && ctx && ctx.setTempo) {
        ctx.setTempo(ctx.tempoBase * Math.max(0.25, Math.min(4, 1+value)));
      } else if (target === 'pitch'){
        const semi = value;
        if (ctx && ctx.detune) ctx.detune.value = (ctx.detuneBase||0) + semi*100;
        else if (ctx && ctx.playbackRate) ctx.playbackRate.value = (ctx.pbBase||1) * Math.pow(2, semi/12);
      } else if (target === 'toneLevel' || target === 'toneFreq'){
        const host = ctx && ctx.el ? ctx.el : document;
        const mods = host.querySelectorAll('.mod');
        let tone = null;
        mods.forEach(m => {
          const hdr = m.querySelector('.mod-hdr .name, .mod-hdr .mod-name, .mod-hdr .title, .mod .hdr .name');
          if (hdr && /tone/i.test(hdr.textContent)) tone = tone || m;
        });
        if (tone){
          const ranges = tone.querySelectorAll('input[type="range"]');
          let targetRange = (target === 'toneLevel') ? (ranges[ranges.length-1] || null) : (ranges[0] || null);
          if (targetRange){
            const min = parseFloat(targetRange.min || "0"), max = parseFloat(targetRange.max || "1");
            const v = Math.max(min, Math.min(max, (min + max)/2 + value * (max - min)/2));
            targetRange.value = String(v);
            targetRange.dispatchEvent(new Event('input', { bubbles: true }));
          }
        }
      }
    } catch(e) {}
  }



  function ctxFor(modEl){
    const host = modEl.closest('.stream, .block, [data-stream]') || document;
    if (host.__modCtx) return host.__modCtx;
    const actx = window.ACTX || window.audioCtx || (window.AudioContext ? new AudioContext() : null) || null;
    return (host.__modCtx = {
      el: host, actx,
      out: window._MASTER_OUT || null,
      pan: null, lpf: null, ab: null,
      tempoBase: window._GLOBAL_TEMPO || 120,
      playbackRate: null, pbBase: 1,
      detune: null, detuneBase: 0
    });
  }

  function ensureSubtabs(mod){
    if (mod.__hasSubtabs) return;
    const body = mod.querySelector('.mod-body') || mod;
    const keep = Array.from(body.children);
    const bar = document.createElement('div');
    bar.className = 'subtabs';
    bar.style.cssText = 'display:flex;gap:8px;margin:6px 0 10px';
    const b1 = Object.assign(document.createElement('button'),{textContent:'LFO',className:'btn btn-xs active'});
    const b2 = Object.assign(document.createElement('button'),{textContent:'Advanced',className:'btn btn-xs'});
    bar.append(b1,b2);
    const paneLFO = document.createElement('div'); paneLFO.className='tab-pane lfo-pane';
    keep.forEach(ch=>paneLFO.appendChild(ch));
    const lfoExtras = document.createElement('div');
    lfoExtras.className='row'; lfoExtras.innerHTML =
      '<label style="margin-left:8px">Phase</label><input class="lfoPhase" type="range" min="0" max="1" step="0.01" value="0">'+
      '<label>Jitter</label><input class="lfoJitter" type="range" min="0" max="1" step="0.01" value="0">'+
      '<label>Offset</label><input class="lfoOffset" type="range" min="-1" max="1" step="0.01" value="0">'+
      '<label><input class="lfoSync" type="checkbox"> Sync</label>';
    paneLFO.appendChild(lfoExtras);

    const paneADV = document.createElement('div'); paneADV.className='tab-pane adv-pane'; paneADV.style.display='none';
    paneADV.innerHTML = [
      '<div class="row euclid">',
      '<button class="btn euOn">Euclid: OFF</button>',
      '<label>Target</label>',
      '<select class="euTarget" title="Destination parameter"><option value="vol">Volume</option><option value="pan">Pan</option><option value="lpf">LPF</option><option value="ab">A↔B</option><option value="tempo">Tempo</option><option value="pitch">Pitch</option></select>',
      '<label>Steps</label><input class="euSteps" title="Total steps in the pattern" type="number" min="1" max="32" value="16" style="width:56px">',
      '<label>Pulses</label><input class="euPulses" title="Number of hits per cycle" type="number" min="0" max="32" value="8" style="width:56px">',
      '<label>Rotate</label><input class="euRotate" title="Rotate pattern start" type="number" min="0" max="31" value="0" style="width:56px">',
      '<label>Depth</label><input class="euDepth" title="Modulation depth" type="range" min="0" max="1" step="0.01" value="1">',
      '<label>Rate</label><select class="euRate" title="Step rate"><option>1/4</option><option selected>1/8</option><option>1/16</option></select>',
      '</div>',
      '<div class="row xy" style="align-items:center;gap:10px;">',
      '<button class="btn xyOn">XY: OFF</button>',
      '<div class="xyPad" title="Drag to modulate assigned targets" style="width:140px;height:100px;border:1px solid var(--select-border,#888);background:rgba(0,0,0,0.12);position:relative;touch-action:none"><div class="xyDot" style="position:absolute;width:10px;height:10px;border-radius:50%;background:var(--accent,#09f);transform:translate(-50%,-50%);left:50%;top:50%"></div></div>',
      '<div>',
      '<label>X→</label><select class="xyX" title="X-axis target"><option value="pan">Pan</option><option value="vol">Volume</option><option value="lpf">LPF</option><option value="ab">A↔B</option></select>',
      '<label>Depth</label><input class="xyXDepth" title="X-axis depth" type="range" min="0" max="1" step="0.01" value="1"><br>',
      '<label>Y→</label><select class="xyY" title="Y-axis target"><option value="vol">Volume</option><option value="pan">Pan</option><option value="lpf">LPF</option><option value="ab">A↔B</option></select>',
      '<label>Depth</label><input class="xyYDepth" title="Y-axis depth" type="range" min="0" max="1" step="0.01" value="1">',
      '</div>',
      '<label style="margin-left:10px"><input class="xyRec" title="Record XY movement (if supported)" type="checkbox"> Record</label>',
      '</div>',
      '<div class="row macros" style="flex-wrap:wrap;gap:8px;">',
      '<button class="btn mcOn">Macros: ON</button>',
      '<div class="macWrap"></div>',
      '<button class="btn mcSnap">Snapshot</button>',
      '<button class="btn mcMorph">Morph</button>',
      '</div>',
      '<div class="row chord">',
      '<button class="btn chOn">Chord: OFF</button>',
      '<label>Key</label>',
      '<select class="chKey" title="Key center"><option>C</option><option>C#</option><option>D</option><option>Eb</option><option>E</option><option>F</option><option>F#</option><option>G</option><option>Ab</option><option>A</option><option>Bb</option><option>B</option></select>',
      '<label>Scale</label>',
      '<select class="chScale" title="Scale / mode"><option>Major</option><option>Minor</option><option>Dorian</option><option>Mixolydian</option><option>Pentatonic</option><option>Chromatic</option></select>',
      '<label>Pattern</label><input class="chPat" title="Comma-separated semitone offsets, e.g. 0,4,7" type="text" value="0,4,7,12" style="width:120px" title="Comma-separated semitone offsets, e.g. 0,4,7">',
      '<label>Rate</label><select class="chRate" title="Arp rate"><option>1/4</option><option selected>1/8</option><option>1/16</option></select>',
      '<label>Depth</label><input class="chDepth" title="Pitch depth in semitones" type="range" min="0" max="1" step="0.01" value="1">',
      '<label>Swing</label><input class="chSwing" title="Swing amount" type="range" min="0" max="0.5" step="0.01" value="0">',
      '<label>Quantize</label><input class="chQuant" title="Quantize to scale" type="checkbox" checked>',
      '</div>'
    ].join('');
    body.innerHTML=''; body.append(bar,paneLFO,paneADV);
    function show(which){ if(which==='lfo'){ paneLFO.style.display=''; paneADV.style.display='none'; b1.classList.add('active'); b2.classList.remove('active'); } else { paneLFO.style.display='none'; paneADV.style.display=''; b2.classList.add('active'); b1.classList.remove('active'); } }
    b1.addEventListener('click',()=>show('lfo')); b2.addEventListener('click',()=>show('adv')); show('lfo');
    mod.__hasSubtabs = true;
  }

  /* Euclidean pattern */
  function bjorklund(steps,pulses,rot){
    steps=Math.max(1,Math.min(32,Math.floor(+steps||1)));
    pulses=Math.max(0,Math.min(steps,Math.floor(+pulses||0)));
    let pattern = Array(pulses).fill([1]), rests = Array(steps-pulses).fill([0]);
    while(rests.length>1){
      const r=Math.min(pattern.length, rests.length), next=[];
      for(let i=0;i<r;i++) next.push(pattern[i].concat(rests[i]));
      pattern = next.concat(pattern.slice(r)); rests = rests.slice(r);
    }
    let flat = pattern.flat();
    const k = (Math.floor(+rot||0))%steps; if(k) flat = flat.slice(k).concat(flat.slice(0,k));
    return flat;
  }

  function wireEuclid(scope, ctx){
    const on = scope.querySelector('.euOn'); if(!on || on.__wired) return; on.__wired = true;
    const tgt=scope.querySelector('.euTarget'), stp=scope.querySelector('.euSteps'),
          pul=scope.querySelector('.euPulses'), rot=scope.querySelector('.euRotate'),
          dep=scope.querySelector('.euDepth'), rate=scope.querySelector('.euRate');
    const st = { on:false, pat:[], idx:0, t0:now(), tPrev:0, depth:+dep.value||1, rate:rate.value, target:tgt.value };
    function rebuild(){ st.pat = bjorklund(stp.value, pul.value, rot.value); st.idx = 0; }
    on.addEventListener('click',()=>{ st.on=!st.on; on.textContent='Euclid: '+(st.on?'ON':'OFF'); st.t0=now(); st.tPrev=0; });
    [stp,pul,rot].forEach(x=> x.addEventListener('change',rebuild));
    dep.addEventListener('input',()=> st.depth = +dep.value || 1);
    rate.addEventListener('change',()=> st.rate = rate.value);
    tgt.addEventListener('change',()=> st.target = tgt.value);
    rebuild();
    TICKERS.push(function(ts){
      if(!st.on) return;
      const tempo=window._GLOBAL_TEMPO||ctx.tempoBase||120, spb=60/Math.max(20,tempo);
      const div=st.rate==='1/16'?4:(st.rate==='1/4'?1:2), dur=spb/div;
      const t=(ts-st.t0)/1000;
      if(t-(st.tPrev||0)>=dur){ st.tPrev+=dur; const hit=st.pat[st.idx%st.pat.length]; const v=hit?(st.depth||1):0; applyTo(st.target, hit?v:-v, ctx); st.idx++; }
    });
  }

  function wireXY(scope,ctx){
    const on=scope.querySelector('.xyOn'); if(!on||on.__wired) return; on.__wired=true;
    const pad=scope.querySelector('.xyPad'), dot=scope.querySelector('.xyDot');
    const X=scope.querySelector('.xyX'), Y=scope.querySelector('.xyY');
    const Xd=scope.querySelector('.xyXDepth'), Yd=scope.querySelector('.xyYDepth');
    const st={on:false,x:0,y:0};
    on.addEventListener('click',()=>{ st.on=!st.on; on.textContent='XY: '+(st.on?'ON':'OFF'); });
    function set(ev){
      if(!st.on) return;
      const r=pad.getBoundingClientRect(), x=Math.max(0,Math.min(1,(ev.clientX-r.left)/r.width)), y=Math.max(0,Math.min(1,(ev.clientY-r.top)/r.height));
      st.x=x*2-1; st.y=(1-y)*2-1; dot.style.left=(x*100)+'%'; dot.style.top=(y*100)+'%';
      applyTo(X.value, st.x*(+Xd.value||0), ctx); applyTo(Y.value, st.y*(+Yd.value||0), ctx);
    }
    ['pointerdown','pointermove'].forEach(t=>pad.addEventListener(t,set));
  }

  function wireMacros(scope, ctx){
    const on=scope.querySelector('.mcOn'); if(!on||on.__wired) return; on.__wired=true;
    const wrap=scope.querySelector('.macWrap'), snap=scope.querySelector('.mcSnap'), morph=scope.querySelector('.mcMorph');
    const M=8, S={vals:Array(M).fill(0), routes:Array(M).fill([]), A:null, B:null};
    if(!wrap.childElementCount){
      for(let i=0;i<M;i++){
        const c=document.createElement('div'); c.style.cssText='display:inline-flex;flex-direction:column;align-items:center';
        c.innerHTML='<div style="font-size:10px">M'+(i+1)+'</div><input class="mVal" title="Macro value" type="range" min="-1" max="1" step="0.01" value="0" style="width:100px"><button class="btn btn-xs mRoute">Route</button>';
        const s=c.querySelector('.mVal');
        s.addEventListener('input',()=>{ S.vals[i]=+s.value; for(const r of S.routes[i]) applyTo(r.target, S.vals[i]*r.depth, ctx); });
        c.querySelector('.mRoute').addEventListener('click',()=>{
          const t=(prompt('Target (vol|pan|lpf|ab|tempo|pitch):','pan')||'pan').trim();
          const d=+prompt('Depth (-1..1):','0.5')||0.5; S.routes[i].push({target:t,depth:d});
        });
        wrap.appendChild(c);
      }
    }
    snap.addEventListener('click',()=>{ if(!S.A) S.A=S.vals.slice(0); else S.B=S.vals.slice(0); });
    morph.addEventListener('click',()=>{
      if(!S.A||!S.B) return; let k=0; const dur=0.5;
      const step=()=>{ k=Math.min(1,k+1/60/dur);
        wrap.querySelectorAll('.mVal').forEach((el,i)=>{ const v=S.A[i]+(S.B[i]-S.A[i])*k; S.vals[i]=v; el.value=v; for(const r of S.routes[i]) applyTo(r.target, v*r.depth, ctx); });
        if(k<1) requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    });
  }

  const SCALES={Major:[0,2,4,5,7,9,11],Minor:[0,2,3,5,7,8,10],Dorian:[0,2,3,5,7,9,10],Mixolydian:[0,2,4,5,7,9,10],Pentatonic:[0,3,5,7,10],Chromatic:[0,1,2,3,4,5,6,7,8,9,10,11]};
  const KEYS={C:0,'C#':1,D:2,Eb:3,E:4,F:5,'F#':6,G:7,Ab:8,A:9,Bb:10,B:11};
  function nearest(semi,key,scale){
    const off=((semi%12)+12)%12, allow=SCALES[scale]||SCALES.Major;
    if(allow.includes(off)) return semi;
    let best=semi, d=99;
    for(let s=semi-6;s<=semi+6;s++){
      const o=((s%12)+12)%12;
      if(allow.includes(o)){ const dd=Math.abs(s-semi); if(dd<d){ d=dd; best=s; } }
    }
    return best;
  }
  const parsePat=t=>String(t||'').split(/[, ]+/).map(s=>+s).filter(Number.isFinite);

  function wireChord(scope,ctx){
    const on=scope.querySelector('.chOn'); if(!on||on.__wired) return; on.__wired=true;
    const key=scope.querySelector('.chKey'), scale=scope.querySelector('.chScale'), pat=scope.querySelector('.chPat'),
          rate=scope.querySelector('.chRate'), depth=scope.querySelector('.chDepth'), swing=scope.querySelector('.chSwing'),
          quant=scope.querySelector('.chQuant');
    const st={on:false, idx:0, t0:now(), tPrev:0, arr:parsePat(pat.value)};
    on.addEventListener('click',()=>{ st.on=!st.on; on.textContent='Chord: '+(st.on?'ON':'OFF'); st.t0=now(); st.tPrev=0; st.idx=0; });
    pat.addEventListener('change',()=> st.arr=parsePat(pat.value));
    TICKERS.push(function(ts){
      if(!st.on || !st.arr.length) return;
      const tempo=window._GLOBAL_TEMPO||ctx.tempoBase||120, spb=60/Math.max(20,tempo);
      const div=rate.value==='1/16'?4:(rate.value==='1/4'?1:2), dur=spb/div, sw=+swing.value||0;
      const k=KEYS[key.value]||0, sc=scale.value, t=(ts-st.t0)/1000, adj=(st.idx%2? sw*dur:0);
      if(t-(st.tPrev||0)>=dur+adj){
        st.tPrev += dur+adj;
        let semi = st.arr[st.idx % st.arr.length];
        if(quant.checked) semi = nearest(semi+k, k, sc) - k;
        applyTo('pitch', (+depth.value||1) * semi, ctx);
        st.idx++;
      }
    });
  }

  function wire(mod){
    ensureSubtabs(mod);
    const adv=mod.querySelector('.adv-pane'), ctx=ctxFor(mod);
    wireEuclid(adv,ctx); wireXY(adv,ctx); wireMacros(adv,ctx); wireChord(adv,ctx);
  }
  function boot(root){
    (root||document)
      .querySelectorAll(".mod.modMatrix, .mod.modulation, .mod.mod-modulation")
      .forEach(m=>{ try { wire(m); } catch(e){} });
  }

  document.addEventListener('DOMContentLoaded',()=>boot(document));
  new MutationObserver((mutations)=>{
    mutations.forEach(m=>{
      if (m.addedNodes) m.addedNodes.forEach(n=>{ if (n.nodeType===1) boot(n); });
    });
  }).observe(document.body,{childList:true,subtree:true});
})();
</script>

<script id="theme-guard-v1">
(function(){
  function applyTheme(txt){
    const b=document.body;
    b.classList.remove('theme-98','theme-xp');
    if(/windows\s*98/i.test(txt)) b.classList.add('theme-98');
    else if(/windows\s*xp/i.test(txt)) b.classList.add('theme-xp');
  }
  document.addEventListener('change',function(e){
    const el=e.target;
    if(el && el.tagName==='SELECT'){
      const txt=(el.selectedOptions&&el.selectedOptions[0]&&el.selectedOptions[0].textContent)||el.value||'';
      const all=Array.from(el.options||[]).map(o=>o.textContent).join('|');
      if(/Flat|Windows\s*98|Windows\s*XP/i.test(all)) applyTheme(txt);
    }
  }, true);
  setInterval(function(){
    const selects = Array.from(document.querySelectorAll('select'));
    const anyThemeSelect = selects.some(s=>/Flat|Windows\s*98|Windows\s*XP/i.test(Array.from(s.options||[]).map(o=>o.textContent).join('|')));
    if(anyThemeSelect){
      const current = selects.map(s=> (s.selectedOptions&&s.selectedOptions[0]&&s.selectedOptions[0].textContent)||s.value||'').join(' | ');
      if(/Flat/i.test(current) && !/Windows\s*98|Windows\s*XP/i.test(current)){
        document.body.classList.remove('theme-98','theme-xp');
      }
    }
  }, 600);
})();
</script>
<script>
(function(){
  function installAB(root){
    (root||document).querySelectorAll('.mod').forEach(m=>{
      if(m.classList.contains('fxMod') || m.classList.contains('spaceMod')){ 
        const old=m.querySelector('.abPick'); if(old) old.remove(); 
        return; 
      }
      if(m.querySelector('.abPick')) return;
      const hdr=m.querySelector('.mod-hdr'); if(!hdr) return;
      const sel=document.createElement('select'); sel.className='abPick'; sel.title='Apply to';
      sel.innerHTML='<option value="both">A+B</option><option value="A">A only</option><option value="B">B only</option>';
      sel.value = m.dataset.ab || 'both';
      sel.addEventListener('change', ()=>{ m.dataset.ab = sel.value; });
      hdr.insertBefore(sel, hdr.querySelector('.carat'));
    });
  }
  document.addEventListener('DOMContentLoaded', ()=> installAB(document));
  new MutationObserver(m=> m.forEach(r=> r.addedNodes && r.addedNodes.forEach(n=> n.nodeType===1 && installAB(n)))).observe(document.body,{childList:true,subtree:true});
})();
</script>

<script>
(function(){
  function ensureToolbar(){
    const tb=document.getElementById('toolbar'); if(!tb) return;
    if(!document.getElementById('toolbarInner')){
      const inn=document.createElement('div'); inn.id='toolbarInner';
      while(tb.firstChild){ inn.appendChild(tb.firstChild); }
      tb.appendChild(inn);
      const tbtn=document.createElement('div'); tbtn.id='taskButtons'; inn.appendChild(tbtn);
    }
    if(!document.getElementById('tray')){
      const tray=document.createElement('div'); tray.id='tray'; tray.innerHTML='<span id="clock"></span>';
      document.getElementById('toolbar').appendChild(tray);
    }
  }
  function tick(){ const el=document.getElementById('clock'); if(!el) return; const d=new Date(); const p=n=>String(n).padStart(2,'0'); el.textContent=p(d.getHours())+':'+p(d.getMinutes()); }
  function applyTheme(name){
    const b=document.body;
    b.classList.remove('theme-98','theme-xp');
    if(name==='win98') b.classList.add('theme-98'); else if(name==='winxp') b.classList.add('theme-xp');
    try{ localStorage.setItem('nt_theme', name); }catch(_){}
    const p=document.getElementById('themePicker'); if(p) p.value=name;
  }
  window.__applyTheme=applyTheme;
  document.addEventListener('DOMContentLoaded', ()=>{
    ensureToolbar(); tick(); setInterval(tick, 30000);
    const p=document.getElementById('themePicker'); if(p) p.addEventListener('change', e=> applyTheme(e.target.value));
    const key='nt_theme_v'; if(localStorage.getItem(key)!=='4'){ localStorage.setItem('nt_theme','flat'); localStorage.setItem(key,'4'); }
    applyTheme(localStorage.getItem('nt_theme')||'flat');
  });
})();
</script>
</body>
</html>

